blueprint:
  name: Cover Control Automation (CCA)
  description: "# ⭐ Cover Control Automation (CCA) ⭐\n### A comprehensive and highly
    configurable blueprint for roller shutters and roller blinds\n\n**Version**: 2025.06.07\n**Help**:
    [Community Thread](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539)
    | **Source Code**: [github.com/hvorragend](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml)
    | **Tickets**: [Issues](https://github.com/hvorragend/ha-blueprints/issues)\n\n**If
    you would like to support me or say thank you, please click here:**\n### \U0001F64F
    [PayPal Donation](https://www.paypal.com/donate/?hosted_button_id=NQE5MFJXAA8BQ)
    | [Buy me a Coffee](https://buymeacoffee.com/herr.vorragend) \U0001F64F\n\n<details>\n<summary><strong>Features</strong></summary>\n\n✅
    Automatic opening and closing the roller shutters\n✅ Freely configurable time
    windows for opening or closing\n✅ Brightness control and/or control via the sun-elevation\n✅
    The use of scheduler helpers are possible\n✅ Ventilation feature (Currently for
    two-way sensors)\n✅ Resident feature: keep the cover closed if resident is asleep\n✅
    Complete flexibility in almost all parameters (drive delays, waiting times, position
    tolerance)\n✅ Each feature can be activated or deactivated as required\n✅ Dynamic
    conditions possible (see examples in `Details`)\n✅ Extensive automatic sun shading
    with many different setting options (see features in `Details`)\n✅ Added the option
    to save the current status in a helper. This has the advantage that the cover
    can also be in other positions and the automation can still be executed. And manual
    interventions are not constantly overridden with every trigger.\n\n**Sun shading
    features**\n✅ Sun azimuth\n✅ Sun elevation\n✅ Solar irradiation/Light intensity/Illuminance\n✅
    Weather Conditions\n✅ Two different temperature sensors (compare thresholds for
    indoor and/or outdoor sensors)\n✅ Not only the current temperature, but also the
    temperature forecast can also be taken into account.\n✅ If multiple criteria (e.g.
    temperature sensors and/or azimuth and/or elevation) are defined, shading will
    not occur until <ins>all</ins> criteria are met.\n\n</details>\n\n<details>\n<summary><strong>License
    notice</strong></summary>\n\n*(Based on the text by SirGoodenough)*\n* Copies
    of the original Blueprint that were converted via the 'Take Control' feature or
    other means are officially not supported by me.\n* I may or may not be able to
    support you when you have a problem after you make changes to my code, as some
    of the code is no longer mine.\n* I & my license also require attribution as a
    link back to the original should you use this code in your own creation.\n* [Here
    is a link to my license & the original github post](https://github.com/hvorragend/ha-blueprints/?tab=License-1-ov-file)
    expected to be followed & referenced as attribution should you use this code elsewhere.\n\n</details>\n\n<details>\n<summary><strong>Important
    notes</strong></summary>\n\n- <strong>It is <ins>not</ins> not possible to execute
    this automation manually! Unless you use it exclusively for the configuration
    check!!</strong>\n- If you want to use sun elevation and/or azimuth it's strongly
    advised to use sun.sun. And please make sure your sun.sun entity is enabled!\n-
    `time_up_early` should be earlier than `time_up_late`\n- `time_up_early_non_workday`
    should be earlier than `time_up_late_non_workday`\n- `time_down_early` should
    be earlier than `time_down_late`\n- `time_down_early_non_workday` should be earlier
    than `time_down_late_non_workday`\n- `shading_azimuth_start` should be lower than
    `shading_azimuth_end`\n- `shading_elevation_min` should be lower than `shading_elevation_max`\n-
    `shading_sun_brightness_start` should be higher than `shading_sun_brightness_end`\n-
    `open_position` should be higher than `close_position`\n- `open_position` should
    be higher than `ventilate_position`\n- `close_position` should be lower than `ventilate_position`\n-
    `shading_position` should be higher than `close_position`\n- `shading_position`
    should be lower than `open_position`\n- `resident_sensor` is only allowed to be
    on/off/true/false\n- cover must have a `current_position` attribute\n\n</details>\n\n<details>\n<summary><strong>Latest
    changes</strong></summary>\n\n**Full Changelog**: [CHANGELOG.md](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/CHANGELOG.md)\n\n2025.06.07\n
    \ - Added: Resident check for ventilation #216 (Thanks for the pull request, Astado)\n
    \ - Added: Better description for shading_forecast_sensor (Thanks you, Eimeel)\n
    \ - Fixed: Solve Issue with sun shading end if Tilt Position Control is enabled
    #216 (Thanks for the pull request, Astado)\n  - Fixed: Shades are being opened
    or closed even if they are already #219\n  - Fixed:\n    When the “End Sun Shading
    Immediately When Out Of Range” mode was activated, the shading of the cover was
    not canceled.\n    This was because the new waiting time was set to 0 seconds
    and CCA could not trigger itself in the same second via a helper.\n  - Updated:
    Extensive code refactoring\n  - Updated:\n    Automation mode changed to 'single'
    as a test, because otherwise new triggers in the delay would interfere with processing.\n
    \   In the worst case, I will have to work with {{ state_attr('automation.cca_automation',
    'current') > 0 }} as before to be able\n    to intercept the reciprocal triggers.\n\n2025.05.27\n
    \ - Updated: Revised information text for configuring the position configuration\n
    \ - Added: The schedule helper state has been added as a variable. This is just
    for debugging purposes. #214\n  - Fixed: The problems with the start of shading
    have been corrected. #212 #211\n    If the shading conditions were not still fulfilled
    after the end of the waiting time, the sun protection was sometimes not activated
    correctly.\n    Now we have a new feature and we can select the following options:\n
    \     - If the conditions were not permanently fulfilled, we can wait for another
    trigger to be executed. The previous pending status is now successfully reset.\n
    \     - And much better: CCA can be configured so that we can periodically check
    the shading during the day. The system then checks again and again until the conditions
    are valid again.\n\n2025.05.20\n  - Fixed: Wrong default value for shading_forecast_temp\n\n2025.05.14\n
    \ - Added: Falling below shading_elevation_max now also triggers Shading Start
    #193\n  - Fixed: When detecting manual position changes, values greater than Ventilation
    were incorrectly assumed to be Open. This was too This was too wide-ranging.\n\n2025.05.13\n
    \ - Fixed: The nightly shading reset has changed the timestamp and therefore a
    new shading with active 'prevent_shading_multiple_times' can never be executed.\n\n2025.05.12:\n
    \ - Fixed: Multiple triggering of a detected shading has skipped the waiting time
    until execution #206\n\n2025.05.11:\n  - Fixed: Fixed bug that the cover can be
    opened again by the time-up-late-trigger despite existing shading.\n\n2025.05.07:\n
    \ - Fixed: Shading is now also recognized and temporarily stored in the helper
    if the resident sensor contains the value true. #131\n  - Added: Tilt Reposition
    Feature (Thanks for the pull request, Astado) #196\n  - Update: Better textual
    clarification of what the result of the additional condition should look like
    #204\n  - Update: Only shade the cover when it is not in the shading position.
    Purely as a precautionary measure in case the target state and actual state do
    not match.\n\n2025.05.04:\n  - Added: Allow immediate ending of shading if the
    sun is out of the defined azimuth or elevation range #202 (Thanks for the pull
    request, jpawlowski)\n  - Added: Option to close cover instead of opening when
    shading ends (ideal for awnings) #203 (Thanks for the pull request, jpawlowski)\n
    \ - Updated: Note that the weather sensor specification is optional #198\n\n2025.05.02-02:\n
    \ - Fixed: A bug has been fixed that caused the shading to be recognized but not
    executed. But only if shading was only allowed to be executed once a day.\n\n2025.05.02-01:\n
    \ - Fixed: Also take into account for shading that a door contact only needs to
    be tested when ventilation mode is switched on #197\n  - Fixed: Removed protocol
    error that occurs during manual execution.\n  - Added: Catching an incorrect weather
    configuration\n  - Added: Ability to specify an existing sensor if it already
    provides daily maximum temperature forecast instead of weather entity #199\n  -
    Added: Add hysteresis for temperature sensor based shading #189\n\n2025.04.18:\n
    \ - Updated: Just to be more bulletproof, the tilt position control can now be
    specifically switched on or off. Please activate if necessary. #163\n  - Updated:
    There is no default value for \"Sun Shading Forecast Temperature\" here now. To
    not compare the forecast temperature, leave this field empty. #179\n  - Added:
    Allow entities of the switch domain as resident sensor or with the force entities
    #167\n  - Added: New additional actions: Commands can now be executed before opening,
    closing, shading and ventilation #166\n  - Fixed: Fixed problems resetting manual
    override #184\n  - Fixed: Make sure that the reset of the manual override is only
    executed once #178\n  - Fixed: Problems with lockout protection and partial ventilation
    solved #181\n  - Fixed: There was no latest time for closing the cover when the
    scheduler was used with sun/brightness #170\n  - Added: Added Sun elevation examples
    into the description #175\n  - Added: New feature 'Allow opening the cover when
    resident is still present' #192\n  - Breaking change: Please reconfigure \"Allow
    sun protection when resident is still present\" ('resident_shading_enabled' was
    renamed)\n\n2024.12.20:\n  - Added: Additional Condition For Disabling Ventilation\n
    \ - Fixed: Small scheduler fix and description also updated\n  - Update: Update
    of the logic and documentation for the resident sensor #158\n\n2024.10.21:\n  -
    Added: The delay values in relation to the contact sensors can now be configured
    individually #149\n  - Fixed: A problem with the scheduler in connection with
    the sun height/brightness has been fixed\n  - Updated: YAML-Syntax for automations.
    Minimum version of the core raised to 2024.10.\n\n2024.09.25:\n  - Fixed: Shutter
    up in the morning while Resident asleep #145\n  - Fixed: Some warnings\n  - Minor
    clean-up work\n\n2024.09.19:\n  - Fixed: Fixed some warnings in the log. No influence
    on functionality #141\n  - Fixed: Brightness Down not working #144\n  - Fixed:
    Shutter up after resident on not (always) functional #139\n\n2024.09.05:\n  -
    Added check for a shading shading start/end time > 0\n\n2024.09.04:\n  - Major
    Update:\n      - Complete redesign of the logic behind the contact sensors.\n
    \     - Splitting the contact sensors into \"Tilted windows\" and \"Open windows\"\n
    \     - Lockout protection removed from the automation options\n      - Lockout
    protection can be configured individually\n      - <strong>Please reconfigure
    contacts,  residents and manual override settings!</strong>\n\n  - Major Update:\n
    \     - Complete redesign of the shading triggers.\n        I have now separated
    the originally combined triggers again.\n        And the waiting time is no longer
    taken into account in the trigger and also not as a delay in the action sequences.\n
    \       Instead, the new trigger time is now saved in the helper.\n        This
    has the wonderful advantage that we can work with several shading triggers again,
    which do not reset and restart each other.\n        Unfortunately, this makes
    things more complicated in support, as I now need traces for both triggers (pending
    and execution).\n        But I also hope to have fewer customer service calls
    in the long term.\n        In addition, you can now see traces again that were
    previously not available because they were cancelled directly in the for-wait
    time.\n\n  - Updated: If you previously used the manual control reset at a certain
    time, you now have to reconfigure this feature once. I had to rename the variable
    is_reset_time to is_reset_fixed_time.\n  - Added: Config check for schedule helper\n
    \ - Added: Sun shading can now be allowed even if a resident is present #131\n
    \ - Fixed: A delay is now also taken into account when the sun shading is ended
    #128\n  - Fixed: When checking the end of shading, a True was always output if
    the weather conditions array was empty #133\n  - Fixed: Prevent double triggering
    if early+late times are identical.\n\n  - Breaking Changes:\n      <ins>Removed
    settings:</ins>\n      - \"Prevent the cover from closing immediately after deactivating
    the lockout protection\" (prevent_close_after_lockout)\n      - \"Enable lockout
    protection\" (auto_lockout_protection_enabled)\n      - \"Contact Sensor Entity
    For Ventilation\" (contact_sensor)\n      - \"Contact Sensor Entity For Lockout
    Protectio\" (contact_sensor_lockout)\n      - \"Prevent automatic closing due
    to the resident sensor\" (prevent_closing_by_resident)\n\n      <ins>Please delete
    the following variables in the YAML code:</ins>\n      - prevent_close_after_lockout\n
    \     - auto_lockout_protection_enabled\n      - contact_sensor\n      - contact_sensor_lockout\n
    \     - prevent_closing_by_resident\n      - is_reset_time (replaces with is_reset_fixed_time)\n\n2024.08.03:\n
    \ - Fixed: Helper length analysis template variable warning #120\n  - Fixed: New
    trigger \"t_shading_reset\" causes errors #119\n  - Fixed: \"Manual Override\"
    don't work #122 (Thanks for the pull request, Eimeel)\n  - Fixed: Commenting out
    the check of the position information in the config check #121\n  - Fixed: Blinds
    not opening with resident mode when auto close disabled #115\n\n2024.07.31:\n
    \ - Fixed: Override conditions were incorrect #109\n  - Fixed: Faulty timing triggers
    although they have been deactivated #104\n  - Fixed: Removed duplicate line of
    code without effect #105\n  - Fixed: Reset shading status at midnight that is
    no longer required - but still saved #106\n  - Fixed: Empty weather conditions
    are now taken into account when shading is ended #110\n  - Fixed: When the shading
    is ended, the resident sensor is now also checked so that nobody is woken up #116\n
    \ - Updated: All force situations are now fully cross-checked in all choose-branches\n
    \ - Added: Save the length of the helper for better debugging #107\n  - Added:
    The ventilation position can now be moved to after the sun shading has ended (if
    the contact is open)\n\n2024.07.06:\n  - Fixed: Return to shading after ventilation
    #43\n  - Fixed: When closing the ventilation contact, do not move the roller blind
    if it is already in the correct position #102\n  - Updated: Trigger name renamed
    to make debugging easier for beginners\n  - Added: Additional information on when
    a Cover Status Helper is required\n  - Added: License notification and notice
    about the new <em>Take Control</em>-feature\n\n2024.06.30:\n  - Fixed: Preventing
    errors and warning on manual execution\n  - Fixed: Incorrect time adopted if tomorrow
    is a working day and today is a weekend\n\n2024.06.29:\n  - <strong>Breaking change:</strong>:
    The checkbox introduced in the last update \"reset_manual_detection\" has been
    moved to a separate selection. Please reconfigure.\n  - Added: Time and timeout
    in minutes to reset the manual override #95\n  - Added: Additional Actions After
    Override Reset #94\n  - Fixed: The cover may also be closed after ventilation
    if the down mode is not activated\n  - Many thanks to crandler for the ideas\n\n2024.06.27:\n
    \ - Minor bugfix\n\n2024.06.26:\n  - <strong>Breaking change:</strong> The option
    <em>\"Prevent the use of the 'get_forecasts' service (prevent_forecast_service)\"</em>
    has been removed and replaced by the configuration option under <em>\"Sun Shading
    Forecast Type\"</em>\n  - Fixed: If tomorrow is not a working day, the right time
    is taken now - #80\n  - Fixed: If the blind is moved manually below the shading
    and ventilation position, this is no longer recognised as closed.\n  - Added:
    Additional Actions After Manual Change - #87\n  - Added: You can now decide whether
    you want to use the hourly or daily weather forecast.\n  - Added: It is now possible
    to reset the manual detection of roller blind movements at 00:01 - #86\n\n2024.06.24:\n
    \ - <strong>Breaking change:</strong> 'prevent_higher_position_shading_end' changed
    to new parameter 'prevent_lowering_when_closing_if_shaded'\n  - Added: Limited
    templates for enabling automation triggers\n  - Added: Shading sensor 2 is also
    checked again during shading\n  - Fixed: Occasionally sun shading was performed
    without checking the weather conditions\n  - Fixed: The ventilation position was
    not set correctly when closing the roller blind\n  - Fixed: At the end of sun
    shading, the system no longer moves to the ventilation position\n  - Fixed: Sun
    shading is now also calculated outside the configured times and can be taken into
    account when opening.\n  - Fixed: Option \"Prevent the cover from closing immediately
    after deactivating the lockout protection\"\n  - Many thanks to Eimeel and Bostil\n\n2024.06.05-01:\n
    \ - Added: Optional checking workday tomorrow sensor when closing the cover #71\n
    \ - Updated: GUI section icons to MDI icons\n\n2024.06.04-01:\n  - Major GUI Update:
    Using blueprint sections now (Min-Core-Version: 2024.6.0)\n\n</details>\n"
  source_url: https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml
  domain: automation
  homeassistant:
    min_version: 2024.10.0
  input:
    blind:
      name: "\U0001F3E0 Cover"
      description: 'Which blind or roller shutter should be automated?

        <details> <summary><code><strong>CLICK HERE:</strong> Information about a
        cover group</code></summary>


        In principle, you can use a group here. But please note that there are problems
        with position detection for a group of covers! For example, one cover may
        be at position 100% and the other cover at position 0%. This results in a
        wrong group-value of 50%.


        My clear recommendation is to create **one automation for each cover**.

        </details>'
      selector:
        entity:
          filter:
          - domain:
            - cover
          multiple: false
    feature_section:
      name: Automation Options
      icon: mdi:window-shutter-cog
      collapsed: true
      input:
        auto_options:
          name: "\U0001F449 Automation Options"
          description: 'The options on the right-hand side determine whether the cover
            is allowed to open or to close. <br /><br /> Typically, the opening and
            closing of the roller blinds is managed by a timer (see below). Activation
            of these initial two options (1 and 2) is necessary for the blinds to
            function. <br /><br /> <ins>In addition to the time control</ins>, the
            height of the sun and a brightness sensor can also play a role in regulating
            the opening and closing of the blinds. To access options 3 or 4, activation
            is required. Up to this point, <ins>none</ins> of these settings pertain
            to the protection of the sun. This is activated in the last option. <br
            /><br /> <strong>Important Note:</strong> Configuring the Cover Status
            Helper is <ins>mandatory</ins> for utilizing ventilation mode or for sun
            protection and sunshade control. <br /><br /> This can can be enhanced
            with additional conditions (see below). However, it’s crucial that options
            are remain activated; otherwise, the specified conditions will not function.
            <br /><br /> Please ensure that the relevant sensors are are also included.
            For instance, the brightness control will only operate if a brightness
            sensor is specified.

            </details> <br /><br /> <details> <summary><code><strong>CLICK HERE:</strong>
            Some notes on multiple triggering</code></summary>


            Even if multiple opening, closing, shading, etc. is activated, this only
            works if a trigger is available. However, the numeric state triggers only
            trigger under certain circumstances. Please see notes here [Numeric state
            triggers](https://www.home-assistant.io/docs/automation/trigger/#numeric-state-trigger)

            <em>Crossing the threshold means that the trigger only fires if the state
            wasn''t previously within the threshold. If the current state of your
            entity is `50` and you set the threshold to `below: 75`, the trigger would
            not fire if the state changed to e.g. `49` or `72` because the threshold
            was never crossed. The state would first have to change to e.g. `76` and
            then to e.g. `74` for the trigger to fire.</em>

            </details>'
          default:
          - auto_up_enabled
          - auto_down_enabled
          - auto_brightness_enabled
          - auto_sun_enabled
          selector:
            select:
              options:
              - label: "\U0001F53C - Enable generic automatic opening of the day in
                  the morning"
                value: auto_up_enabled
              - label: "\U0001F53B - Enable generic automatic daily closing at the
                  end of the day"
                value: auto_down_enabled
              - label: "\U0001F505 - Enable brightness control (in addition to daily
                  opening and closing)"
                value: auto_brightness_enabled
              - label: ☀️ - Enable sun elevation control (in addition to daily opening
                  and closing)
                value: auto_sun_enabled
              - label: "\U0001F4A8 - Enable ventilation mode and lockout protection
                  (helper required)"
                value: auto_ventilate_enabled
              - label: "\U0001F975 - Enable automatic sun protection / sunshade control
                  (helper required)"
                value: auto_shading_enabled
              multiple: true
              sort: false
              custom_value: false
              mode: list
        individual_config:
          name: ⚙️ Individual Configuration
          description: 'Various different options for some fine adjustments

            <details> <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


            <ins>Prevent ''set_cover_position'' and ''set_cover_tilt_position''</ins><br
            /> There are devices that have problems when the two services ''set_cover_position''
            and ''set_cover_tilt_position'' are executed directly one after the other.
            For example, there are Shelly devices that use the script [cover_position_tilt.yaml](https://gist.github.com/lukasvice/b364724d84c3ac4e160f7a7d8fa37066)
            here. Or Homematic blind actuators, which can better use their own service
            for this: [homematicip_local.set_cover_combined_position](https://github.com/SukramJ/custom_homematic?tab=readme-ov-file#homematicip_localset_cover_combined_position).
            This option can be used to disable the standard services and allows the
            control to be implemented individually via the addtional actions.

            </details>'
          default: []
          selector:
            select:
              options:
              - label: "\U0001F6AB Prevent the cover from moving to a higher position
                  when closing in the evening"
                value: prevent_higher_position_closing
              - label: "\U0001F6AB Prevent the position from being lowered when closing
                  in the evening if it is currently shaded"
                value: prevent_lowering_when_closing_if_shaded
              - label: "\U0001F6AB Prevent the end of sun shading when the cover is
                  already closed"
                value: prevent_shading_end_if_closed
              - label: "\U0001F6AB Prevent the opening of the cover after shading
                  ends (office use)"
                value: prevent_opening_after_shading_end
              - label: "\U0001F6AB Prevent the opening of the cover after ventilation
                  ends (office use)"
                value: prevent_opening_after_ventilation_end
              - label: "\U0001F6AB Prevent the use of 'set_cover_position' and 'set_cover_tilt_position'
                  and only use the additional actions"
                value: prevent_default_cover_actions
              - label: "\U0001F6AB Prevent the cover from being opened several times
                  a day"
                value: prevent_opening_multiple_times
              - label: "\U0001F6AB Prevent the cover from being closed several times
                  a day"
                value: prevent_closing_multiple_times
              - label: "\U0001F6AB Prevent the cover from being shaded several times
                  a day"
                value: prevent_shading_multiple_times
              multiple: true
              sort: false
              custom_value: false
              mode: list
    helper_section:
      name: Cover Status Helper
      icon: mdi:form-textbox
      collapsed: true
      input:
        cover_status_options:
          name: "\U0001F9AE Status detection of the cover"
          description: 'It is essential that the cover has the <em>current_position</em>
            attribute. Regardless of which option is selected here, the position detection
            is based on this attribute. The <em>current_tilt_position</em> attribute
            is <ins>not</ins> taken into account.


            <strong>Important note:</strong><br /> - I strongly recommend using the
            Cover Status Helper! The full range of functions is only available if
            this is configured.<br /> - The helper is required for shading, ventilation
            and lockout protection!<br />


            <details> <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            - <ins>Check the current position</ins><br /> The automation only moves
            the cover if it is positioned at one of the defined positions (ventilate
            position, shading position, open position or closed position). Otherwise,
            the cover has been moved manually. After a manual drive, it is unclear
            what is intended to be achieved, so the automation no longer takes action.
            To automate the drive of the cover again, it must be moved to one of the
            defined positions beforehand. The advantage of this is that you don''t
            have to create a helper in Home Assistant. Only basic features are available
            with this setting.


            - <ins>Use an external Cover Status Helper</ins><br /> If you want to
            be able to do manual overrides and have the automation do the next drive
            as usual, then a helper is necessary. Without a helper, the manual override
            would always be overwritten by the automation. This has the advantage
            that the cover does not necessarily have to be in a defined position.
            With this choice, advanced functions are possible and you can always rely
            on the automation.


            </details>

            '
          default: cover_helper_disabled
          selector:
            select:
              options:
              - label: '#️⃣ Check the current position'
                value: cover_helper_disabled
              - label: "\U0001F9AE Also use an external Cover Status Helper (better)"
                value: cover_helper_enabled
              multiple: false
              sort: false
              custom_value: false
        cover_status_helper:
          name: "\U0001F9AE Cover Status Helper"
          description: Helper used to store the last cover event. A separate helper
            must be created for each CCA automation. *Attention:* You will need to
            manually create a [input_text](https://my.home-assistant.io/redirect/helpers/)
            entity with a <ins>length of 254 chars</ins> for this.
          default: []
          selector:
            entity:
              domain:
              - input_text
              multiple: false
        drive_time:
          name: ⏲️ Cover Drive Time
          description: Can be used to recognise manual control. Please round up a
            little and do not adjust too precisely. Is used to delay the trigger if
            too much or incorrect position data is sent back. <br /><br /> Within
            this time, it is assumed that CCA has carried out the last action. Otherwise,
            CCA would react to its own commands and recognize them as manual intervention.
          default: 90
          selector:
            number:
              min: 0.0
              max: 180.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider
    position_section:
      name: Cover Position Settings
      icon: mdi:window-shutter-settings
      description: "<br /><center>\n  <details>\n      <summary><code><strong>CLICK
        HERE:</strong> Important notes on configuring the position values</code></summary>\n
        \     <code>\n      Please ensure that all position values are unique and
        do not conflict with each other.<br />\n      Correct position values are
        essential (e.g. open_position must be greater than closed_position).<br />\n
        \     The shading and ventilation positions must also be unique, i.e. they
        must not match any other values.<br />\n      For more information, please
        refer to the important notes at the top of the blueprint description or the
        second post in the CCA community thread.<br /><br />\n      Attention: Bear
        in mind that, if you include the tolerance, the other positions are not too
        close to each other.<br />\n      The following would cause problems and be
        incorrect:<br />\n      Open Position = 100 / Ventilate Position = 99 / Tolerance
        >= 1<br />\n    </code>\n  </details>\n</center><br />"
      collapsed: true
      input:
        open_position:
          name: "\U0001F53C Open Position"
          description: What position should the cover be moved into when opening?
          default: 100
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        close_position:
          name: "\U0001F53B Close Position"
          description: What position should the cover be moved into when closing?
          default: 0
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        ventilate_position:
          name: "\U0001F4A8 Ventilate Position"
          description: What position should the cover move to when the window is tilted?
            If closing is triggered and the contact sensor is 'on', the cover will
            move to this position instead of closing completely. <br /><br />Should
            not be 100. In this case please use 99. And please also note the information
            in the position tolerance.
          default: 30
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        shading_position:
          name: "\U0001F975 Sun Shading Position"
          description: To which position should the cover be moved for shading?
          default: 25
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        position_tolerance:
          name: 〰️ Position Tolerance
          description: Tolerance to be applied when comparing the current position
            with the to be position. These are absolute values. Not relative to the
            previous position values.
          default: 0
          selector:
            number:
              min: 0.0
              max: 20.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
    tilt_position_section:
      name: Cover Tilt Position Settings
      icon: mdi:image-filter-tilt-shift
      collapsed: true
      input:
        cover_tilt_config:
          name: "\U0001F4D0 Tilt Position Feature"
          description: If the cover and the integration support it, the tilt position
            of the cover can be set. The standard attribute ‘current_tilt_position’
            is used for this. However, the ‘current_position’ attribute is still used
            exclusively for the actual position detection in the blueprint.
          default: cover_tilt_disabled
          selector:
            select:
              options:
              - label: ✅ Enable Tilt Position Control
                value: cover_tilt_enabled
              - label: ❌ Disable Tilt Position Control
                value: cover_tilt_disabled
              multiple: false
              sort: false
              custom_value: false
              mode: list
        cover_tilt_reposition_config:
          name: "\U0001F4D0 Tilt Reposition Feature"
          description: If Tilt Position Feature is enabled you can choose if the blinds
            are closed before tilting to a new position. In some cases tilting the
            blinds in small steps can lead to false positions. This is because of
            the minimum time the motor needs to run. If the runtime between current
            tilt position and target tilt position is to small the motor will not
            stop at the right position. Thus the blinds will be preclosed to 0 and
            then run to the target position.
          default: cover_tilt_reposition_disabled
          selector:
            select:
              options:
              - label: ✅ Enable Tilt Reposition Control
                value: cover_tilt_reposition_enabled
              - label: ❌ Disable Tilt Reposition Control
                value: cover_tilt_reposition_disabled
              multiple: false
              sort: false
              custom_value: false
              mode: list
        open_tilt_position:
          name: "\U0001F53C Open Tilt Position"
          description: To which tilt position should the cover be moved when opening?
          default: 50
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        close_tilt_position:
          name: "\U0001F53B Close Tilt Position"
          description: To which tilt position should the cover be moved when closing?
          default: 50
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        ventilate_tilt_position:
          name: "\U0001F4A8 Ventilate Tilt Position"
          description: To which tilt position should the cover be moved for ventilation?
          default: 50
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        shading_tilt_position_1:
          name: "\U0001F975 Sun Shading Tilt Position 1"
          description: To which tilt position should the cover be moved for shading?
          default: 20
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        shading_tilt_elevation_1:
          name: "\U0001F975 Sun Shading Tilt Elevation 1"
          description: Sun elevationn for tilt position 1.
          default: 20
          selector:
            number:
              min: 0.0
              max: 90.0
              unit_of_measurement: °
              mode: slider
              step: 1.0
        shading_tilt_position_2:
          name: "\U0001F975 Sun Shading Tilt Position 2"
          description: To which tilt position should the cover be moved for shading?
          default: 37
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        shading_tilt_elevation_2:
          name: "\U0001F975 Sun Shading Tilt Elevation 2"
          description: Sun elevationn for tilt position 2.
          default: 30
          selector:
            number:
              min: 0.0
              max: 90.0
              unit_of_measurement: °
              mode: slider
              step: 1.0
        shading_tilt_position_3:
          name: "\U0001F975 Sun Shading Tilt Position 3"
          description: To which tilt position should the cover be moved for shading?
          default: 50
          selector:
            number:
              min: 0.0
              max: 100.0
              unit_of_measurement: '%'
              mode: slider
              step: 1.0
        shading_tilt_elevation_3:
          name: "\U0001F975 Sun Shading Tilt Elevation 3"
          description: Sun elevationn for tilt position 3.
          default: 48
          selector:
            number:
              min: 0.0
              max: 90.0
              unit_of_measurement: °
              mode: slider
              step: 1.0
    time_section:
      name: Time Control Configuration
      icon: mdi:clock-time-two-outline
      collapsed: true
      input:
        time_control:
          name: ⏲️ Selection of time control options
          description: '<details> <summary><code><strong>CLICK HERE:</strong> Further
            descriptions</code></summary> <br /> <ins>Input fields for time control</ins><br
            /> The times for opening and closing the cover are usually configured
            here in the blueprint. There are various input fields here for this purpose.
            Even if you only want to control the covers using brightness values or
            the sun elevation, it is important to specify times. The times are used
            to divide the day into "morning" (up) and "evening" (down). <br /><br
            /> <ins>Schedule Helper</ins><br /> However, you can also activate a scheduler
            helper mode at this point. This would allow you to configure a different
            time period for keeping the cover open for each day. Further information
            on this and the definition of the helper can be found below. <br /><br
            /> <ins>Disable time control and all time triggers</ins><br /> Finally,
            you can also deactivate the time control completely. This means that the
            roller shutters are not opened or closed via time triggers. The sun-elevation
            and brightness control then also runs completely independently.

            </details>'
          default: time_control_input
          selector:
            select:
              options:
              - label: ✏️ Use the time input fields in this blueprint section
                value: time_control_input
              - label: ⏲️ Use an external schedule helper
                value: time_control_schedule
              - label: "\U0001F6AB Disable time control and all time triggers"
                value: time_control_disabled
              sort: false
              multiple: false
              custom_value: false
        time_up_early:
          name: "\U0001F53C Time For Drive Up - Early On Workdays"
          description: 'The earliest time at which the cover may be opened. The cover
            will be opened if <ins>AFTER</ins> this time the defined brightness or
            sun-elevation value is high enough. (**NOTE**: A resident must also be
            awake if one is defined).'
          default: 06:00:00
          selector:
            time: {}
        time_up_early_non_workday:
          name: "\U0001F53C Time For Drive Up - Early On Non-Workdays"
          description: As directly above, but for non-workdays.
          default: 07:00:00
          selector:
            time: {}
        time_up_late:
          name: "\U0001F53C Time For Drive Up - Late On Workdays"
          description: 'The latest time at which the cover should be opened. If the
            required brightness or sun-elevation value has <ins>NOT</ins> yet been
            reached by this time, the cover will still be opened. (**NOTE**: If a
            resident has been defined and the resident is still asleep, then the cover
            will NOT be opened.)'
          default: 08:00:00
          selector:
            time: {}
        time_up_late_non_workday:
          name: "\U0001F53C Time For Drive Up - Late On Non-Workdays"
          description: As directly above, but for non-workdays.
          default: 08:00:00
          selector:
            time: {}
        time_down_early:
          name: "\U0001F53B Time For Drive Down - Early On Workdays"
          description: The earliest time at which the cover may be closed. The cover
            will be closed if <ins>AFTER</ins> this time the defined brightness or
            sun-elevation value is low enough.
          default: '16:00:00'
          selector:
            time: {}
        time_down_early_non_workday:
          name: "\U0001F53B Time For Drive Down - Early On Non-Workdays"
          description: As directly above, but for non-workdays.
          default: '16:00:00'
          selector:
            time: {}
        time_down_late:
          name: "\U0001F53B Time For Drive Down - Late On Workdays"
          description: The latest time at which the cover should be closed. If the
            required brightness or sun-elevation value has <ins>NOT</ins> yet been
            reached by this time, the cover will still be closed. <br /> Please do
            not enter 0:00, because that would be the next day!
          default: '22:00:00'
          selector:
            time: {}
        time_down_late_non_workday:
          name: "\U0001F53B Time For Drive Down - Late On Non-Workdays"
          description: As directly above, but for non-workdays. <br /> Please do not
            enter 0:00, because that would be the next day!
          default: '22:00:00'
          selector:
            time: {}
        workday_sensor:
          name: "\U0001F4BC Sensor For Workday Today"
          description: 'It may be desired to open a cover at a different time on work
            days than on non-work days. The corresponding binary sensor can be defined
            here. If not set, the cover will open every time at time_up_early. <br
            /><br /> I recommend using the [Workday integration](https://www.home-assistant.io/integrations/workday/).
            <br /><br /> Example: `binary_sensor.workday_today` <br /><br />`Optional`'
          default: []
          selector:
            entity:
              filter:
              - domain:
                - binary_sensor
              multiple: false
        workday_sensor_tomorrow:
          name: "\U0001F4BC Sensor For Workday Tomorrow (only for closing)"
          description: 'When <ins>closing</ins> the blinds, you have the option of
            checking the times for tomorrow rather than the current day. This has
            the advantage that you can <ins>close</ins> the blinds earlier if <ins>tomorrow</ins>
            is a working day. This makes sense if, for example, there is school tomorrow
            but today is actually still the weekend. But the child has to go to bed
            earlier.<br /> If this field is not configured here, the normal working
            day sensor is used. <br /><br /> I recommend using the [Workday integration](https://www.home-assistant.io/integrations/workday/).
            <br /><br /> Example: `binary_sensor.workday_tomorrow` <br /><br />`Optional`'
          default: []
          selector:
            entity:
              filter:
              - domain:
                - binary_sensor
              multiple: false
        time_schedule_helper:
          name: ⏲️ Cover driving time schedule helper
          description: "If enabled <em>\"⏲️ Use an external schedule helper\"</em>
            above, please select the schedule helper here. Of course, it is also important
            that the times in the helper are configured accordingly. Please create
            only one period in total. Example: Start at 08:00 and end at 22:00. The
            helper can be created [here](https://my.home-assistant.io/redirect/helpers/).
            <br /><br />`Optional`\n<details> <summary><code><strong>CLICK HERE:</strong>
            Important difference to the usual input fields</code></summary> <br />
            The behaviour when using the schedule Helper is different to the pure
            time input.\n\n  - <ins>Without brightness or sun elevation control:</ins>\n
            \   As soon as the helper state is switched from <strong>OFF</strong>
            to <strong>ON</strong>, the cover is opened.\n    The cover is closed
            when the helper state changes from <strong>ON</strong> to <strong>OFF</strong>.\n\n
            \ - <ins>With brightness or sun elevation control:</ins>\n    The cover
            opens when the threshold is exceeded and the helper is <strong>ON</strong>.\n
            \   The cover closes when the level is below the threshold and the helper
            is <strong>ON</strong>, or when the schedule helper changes from <strong>ON</strong>
            to <strong>OFF</strong> (Latest time for closing the cover).\n\nUnfortunately,
            the HA core currently only has a 30-minute time grid for the time configuration.\n</details>
            <br /> <details> <summary><code><strong>CLICK HERE:</strong> Important
            configuration instructions</code></summary> <br /> It is not possible
            to find out more about the status of the schedule helper in Home Assistant.
            I never know whether we are at the beginning or end of the period. However,
            this is important to avoid bouncing when controlling the brightness, for
            example. In order to recognise whether we are still in the opening period
            or the closing period, it is necessary to enter a very rough time period
            in the time variables in the blueprint. <br /><br /> <ins>Example:</ins>
            If the schedule helper goes to the \"ON\" status at 08:00 and to the \"OFF\"
            status at 18:00, it is sufficient to configure the times as follows: <br
            /><br /> Time For Drive Up - Early: 06:00<br /> Time For Drive Up - Late:
            12:00<br /><br /> Time For Drive Down - Early: 16:00<br /> Time For Drive
            Down - Late: 22:00<br /> <br /> The times are not used for triggering,
            but only to divide the day into two halves!\n</details>"
          default: []
          selector:
            entity:
              filter:
              - domain:
                - schedule
              multiple: false
    brightness_section:
      name: Brightness Configuration
      description: "<br /> <center><code>Settings if the feature ‘\U0001F505 - Enable
        brightness control’ has been activated above.</code></center><br />"
      icon: mdi:brightness-5
      collapsed: true
      input:
        default_brightness_sensor:
          name: "\U0001F505 Default Brightness Sensor"
          description: This default brightness sensor can be defined here, which is
            used for daily up and down.
          default: []
          selector:
            entity:
              filter:
              - domain:
                - sensor
              multiple: false
        brightness_time_duration:
          name: "\U0001F505 Brightness Time Duration"
          description: Defines the time to given brightness sensor must be stay above/below
            the thresholds.
          default: 30
          selector:
            number:
              min: 0.0
              max: 600.0
              mode: slider
              step: 1.0
              unit_of_measurement: seconds
        brightness_up:
          name: "\U0001F505 Brightness Value For Opening The Cover"
          description: At what brightness value should the cover be opened?
          default: 0
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0
              mode: slider
        brightness_down:
          name: "\U0001F505 Brightness Value For Closing The Cover"
          description: At what brightness value should the cover be closed? Must be
            lower then the brightness up value.
          default: 0
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0
              mode: slider
    sun_section:
      name: Sun Elevation Settings
      description: <br /> <center><code>Settings if the feature ‘☀️ - Enable sun elevation
        control’ has been activated above.</code></center><br />
      icon: mdi:weather-sunny
      collapsed: true
      input:
        default_sun_sensor:
          name: ☀️ Sun Sensor
          description: Which sensors provides attributes with current azimuth and
            elevation of sun. I strongly suggest to use sun.sun ([Sun integration](https://www.home-assistant.io/integrations/sun/)).
            Please make sure that the integration is activated and provides the attributes.
            This sensor is also used for sun protection / sunshade control. <br /><br
            /> <ins>A few examples of threshold values:</ins> <ul> <li>+18° Astronomical
            Dusk</li> <li>+12° Nautical Dusk</li> <li>+6° Dusk</li> <li>0° Sunrise/Sunset</li>
            <li>-6° Civil Dawn</li> <li>-12° Nautical Dawn</li> <li>-18° Astronomical
            Dawn/Night</li> </ul> <br />`Optional` / `Shading`
          default: sun.sun
          selector:
            entity:
              filter:
              - domain:
                - sun
              multiple: false
        sun_time_duration:
          name: ☀️ Sun Time Duration
          description: Defines the time to given sun sensor must be stay above/below
            the thresholds.
          default: 30
          selector:
            number:
              min: 0.0
              max: 600.0
              mode: slider
              step: 1.0
              unit_of_measurement: seconds
        sun_elevation_up:
          name: ☀️ Sun Elevation Value For Opening The Cover
          description: The cover will be <ins>opened</ins> if the sun elevation is
            over this value
          default: 0
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: °
              step: 0.1
              mode: slider
        sun_elevation_down:
          name: ☀️ Sun Elevation Value For Closing The Cover
          description: The cover will be <ins>closed</ins> if the sun elevation is
            under this value
          default: 0
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: °
              step: 0.1
              mode: slider
    contacts_section:
      name: Contact Sensors for Ventilation
      description: "<br /> <center><code>Settings if the feature ‘\U0001F4A8 - Enable
        ventilation mode’ has been activated above.</code></center><br /> <center><code>All
        these settings are optional / A Cover Status Helper is required!</code></center><br
        />"
      icon: mdi:door-closed-lock
      collapsed: true
      input:
        contact_window_opened:
          name: "\U0001F6AA Contact Sensor For Open Window (Full Ventilation)"
          description: 'Contact sensor of a door or window handle for detecting <ins>total
            opening</ins>. If this sensor switches to on/true, the cover is <ins>fully
            opened</ins>. At the same time, a lockout protection is <ins>always</ins>
            activated. The cover is not closed and the sun shading is not activated
            when the contact is open.

            <details> <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            It must be a binary two-way contact sensor. If a three-way sensor is available,
            it must be converted to a binary two-way sensor using a [template sensor](https://www.home-assistant.io/integrations/template/).
            See also the [following posts](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539/593)
            in the forum.


            <strong>Important note:</strong> Please do not enter the same sensor in
            both fields for the contact sensors. This does not work and leads to strange
            situations.

            </details>'
          default: []
          selector:
            entity:
              filter:
              - domain:
                - binary_sensor
                - input_boolean
              multiple: false
        contact_window_tilted:
          name: "\U0001F4A8 Contact Sensor For Tilted Window (Partial Ventilation)"
          description: 'The contact sensor is required for the <ins>partial</ins>
            ventilation mode. If the contact changes to on/true, the cover is moved
            to the <ins>ventilation</ins> position. The prerequisite is that the cover
            is already closed. After the status changes to off/false, the close position
            is activated again. The same applies in the shading-out situation.

            <details> <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            It must be a binary two-way contact sensor. If a three-way sensor is available,
            it must be converted to a binary two-way sensor using a [template sensor](https://www.home-assistant.io/integrations/template/).
            See also the [following posts](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539/593)
            in the forum.


            <strong>Important note:</strong> Please do not enter the same sensor in
            both fields for the contact sensors. This does not work and leads to strange
            situations.

            </details>'
          default: []
          selector:
            entity:
              filter:
              - domain:
                - binary_sensor
                - input_boolean
              multiple: false
        lockout_tilted_options:
          name: "\U0001F4A8 Lockout protection for window tilted"
          description: For the tilted window (or door, of course), you can individually
            specify where a lockout protection should be used.
          default: []
          selector:
            select:
              options:
              - label: "\U0001F6E1️ Lockout protection when closing the cover"
                value: lockout_tilted_closing
              - label: "\U0001F6E1️ Lockout protection when starting the sun shading"
                value: lockout_tilted_shading_start
              - label: "\U0001F6E1️ Lockout protection when the sun shading is ended"
                value: lockout_tilted_shading_end
              sort: false
              multiple: true
              custom_value: false
        auto_ventilate_options:
          name: "\U0001F4A8 Ventilation Configuration"
          description: "Various different ventilation options.\n<details> <summary><code><strong>CLICK
            HERE:</strong> Further descriptions</code></summary>\n\n\n  - <ins>Use
            a delay in ventilation mode after closing the contact:</ins>\n    <br
            />\n    Normally, when the window contact is closed, there is no delay
            in the upcoming drives. If you do want this, you can activate it here.\n
            \   <br /><br />\n    The \"Fixed Drive Delay\" and \"Random Drive Delay\"
            settings which are already used everywhere are then used.\n    <br /><br
            />\n  - <ins>Allow ventilation even if cover is already in a higher position:</ins>\n
            \   <br />\n    Activate ventilation mode even if the current position
            of the cover is already higher than the ventilation position.\n    <br
            /><br />\n  - <ins>Using the ventilation position when the sun shade is
            ended:</ins>\n    <br />\n    The cover can also be moved to the ventilation
            position when the sun protection/sun shading is ended.\n    Normally,
            the cover would be fully opened when the shading is ended.\n    <br />\n
            \   To be honest, it makes no sense to switch to the ventilation position
            during the day if more air can flow in when the cover is open.\n\n</details>"
          default: []
          selector:
            select:
              options:
              - label: "\U0001F4A8 Use a delay in ventilation mode after closing the
                  contact"
                value: ventilation_delay_enabled
              - label: "\U0001F4A8 Allow ventilation even if cover is already in a
                  higher position"
                value: ventilation_if_lower_enabled
              - label: "\U0001F4A8 Using the ventilation position when the sun shading
                  is ended (instead of opening it completely)"
                value: ventilation_after_shading_end
              multiple: true
              sort: false
              custom_value: false
              mode: list
        contact_delay_trigger:
          name: "\U0001F55B Contact Trigger Delay"
          description: How many seconds must the status of the contact sensors be
            valid for the automation to trigger?
          default: 2
          selector:
            number:
              min: 0.0
              max: 10.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider
        contact_delay_status:
          name: "\U0001F55B Contact Sensor Status Delay"
          description: How long should the automation wait until a trigger of a contact
            sensor becomes valid? This may be necessary if the status of a three-state
            sensor has an intermediate value for a short time.
          default: 3
          selector:
            number:
              min: 0.0
              max: 10.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider
    shading_section:
      name: Sun Shading / Sun Protection
      description: "<br /> <center><code>Settings if the feature ‘\U0001F975 - Enable
        automatic sun protection / sunshade control’ has been activated above.</code></center><br
        /> <center><code>All these settings are optional / A Cover Status Helper is
        required! / The attributes of default sun sensor (configured above) is used.</code></center><br
        />"
      icon: mdi:shield-sun-outline
      collapsed: true
      input:
        shading_brightness_sensor:
          name: "\U0001F975 Brightness Sensor For Sun Shading"
          description: This sensor is only used for shading.
          default: []
          selector:
            entity:
              filter:
              - domain:
                - sensor
              multiple: false
        shading_sun_brightness_start:
          name: "\U0001F975 Sun Shading Brightness Start Value"
          description: The minimum brightness value from which shading should start.
            (Must be above the value of brightness end!)
          default: 35000
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0
              mode: slider
        shading_sun_brightness_end:
          name: "\U0001F975 Sun Shading Brightness End Value"
          description: The brightness value from which shading is no longer necessary.
            (Must be below the value of brightness start!).
          default: 25000
          selector:
            number:
              min: 0.0
              max: 100000.0
              unit_of_measurement: lx
              step: 1.0
              mode: slider
        shading_azimuth_start:
          name: "\U0001F975 Sun Shading Azimuth Start Value"
          description: What is the minimum azimuth at which the sun hits the window?
            (Shading will start)
          default: 95
          selector:
            number:
              min: 0.0
              max: 365.0
              unit_of_measurement: °
              mode: slider
              step: 1.0
        shading_azimuth_end:
          name: "\U0001F975 Sun Shading Azimuth End Value"
          description: What is the maximum azimuth at which the sun hits the window?
            (Shading will stop)
          default: 265
          selector:
            number:
              min: 0.0
              max: 365.0
              unit_of_measurement: °
              mode: slider
              step: 1.0
        shading_elevation_min:
          name: "\U0001F975 Sun Shading Elevation Minimum Value"
          description: Starting from which elevation of the sun should the window
            be shaded? (Here it makes sense to consider surrounding buildings, trees,
            etc.).
          default: 25
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: °
              step: 0.1
              mode: slider
        shading_elevation_max:
          name: "\U0001F975 Sun Shading Elevation Maximum Value"
          description: What is the maximal elevation for elevation? (In most cases,
            90 degrees is probably the most reasonable value. However, this can also
            be different due to surrounding buildings, etc.).
          default: 90
          selector:
            number:
              min: -90.0
              max: 90.0
              unit_of_measurement: °
              step: 0.1
              mode: slider
        shading_temperatur_sensor1:
          name: "\U0001F975 Sun Shading Temperature Sensor 1 (eg. indoor)"
          description: This is the main temperature sensor. (Here, for example, the
            current indoor temperature can be used as a condition).
          selector:
            entity:
              filter:
              - domain:
                - sensor
              multiple: false
          default: []
        shading_min_temperatur1:
          name: "\U0001F975 Sun Shading Temperature Sensor 1 Minimum Value"
          description: Minimum temperature for sensor 1 above which shading should
            occur.
          default: 18
          selector:
            number:
              min: 0.0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: °C
        shading_temperature_hysteresis1:
          name: "\U0001F975 Sun Shading Temperature Sensor 1 Hysteresis Value"
          description: Shading will end only when temperature drops below (minimum
            - hysteresis value) to prevent frequent open/close cycles.
          default: 0.2
          selector:
            number:
              min: 0.0
              max: 5.0
              step: 0.1
              mode: slider
              unit_of_measurement: °C
        shading_temperatur_sensor2:
          name: "\U0001F975 Sun Shading Temperature Sensor 2 (eg. outdoor)"
          description: This is a secondary temperature sensor. (Here, for example,
            the current outdoor temperature can be used as a condition). This sensor
            has another function. Please read the notes in the <ins>Sun Shading Forecast
            Temperature Value</ins> entry below.
          default: []
          selector:
            entity:
              filter:
              - domain:
                - sensor
              multiple: false
        shading_min_temperatur2:
          name: "\U0001F975 Sun Shading Temperature Sensor 2 Minimum Value"
          description: Minimum temperature for sensor 2 above which shading should
            occur.
          default: 18
          selector:
            number:
              min: 0.0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: °C
        shading_temperature_hysteresis2:
          name: "\U0001F975 Sun Shading Temperature Sensor 2 Hysteresis Value"
          description: Shading will end only when temperature drops below (minimum
            - hysteresis value) to prevent frequent open/close cycles.
          default: 0.2
          selector:
            number:
              min: 0.0
              max: 5.0
              step: 0.1
              mode: slider
              unit_of_measurement: °C
        shading_forecast_sensor:
          name: "\U0001F975 Sun Shading (Forecast) Weather Sensor"
          description: 'This weather sensor (ideally based on a weather integration)
            is used for further temperature comparisons based on the forecast. This
            sensor is also used to compare weather conditions. Leave empty if the
            forecast is not to be used in any case. <p> Select either a weather entity
            (e.g., weather.your_weather_service) or a sensor that provides the forecasted
            daily maximum temperature. </p> <p> **Weather Entity:** If you select
            a weather entity, the maximum temperature will be automatically determined
            from its forecast attributes. This is necessary if your installed weather
            integration does not provide its own sensors for the forecast. </p> <p>
            **Sensor Entity:** If you already have your own sensor for the daily maximum
            temperature (forecast) (e.g., a template sensor), you can specify it directly
            here. This can improve performance and avoid unnecessary queries, as the
            value is read directly from the sensor. Such a sensor is provided, for
            example, by the Pirate Weather integration (sensor.pirateweather_daytime_high_apparent_temperature_0d).
            </p> <details> <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


            The idea is that it can happen, especially in spring, that the value of
            the <em>Forecast Temperature Value</em> exceeded by strong solar radiation
            and the shading would be started. However, in spring you may not want
            shading, but the solar radiation as a welcome, free heating is desired.
            So you can define via the forecast sensor that shading is only started
            at an expected daily maximum temperature.

            You can also specify an existing sensor if it already provides the forecast
            for the maximum daily temperature. In this case set "Sun Shading Forecast
            Type" to "Do not use a weather forecast, but the current weather attributes".

            </details>'
          default: []
          selector:
            entity:
              filter:
              - domain:
                - weather
                - sensor
              multiple: false
        shading_forecast_type:
          name: "\U0001F975 Sun Shading Forecast Type"
          description: 'Please choose whether you want to use the daily forecast or
            the hourly forecast. <br /> The first array member of the weather forecast
            is always used. This means the current day or the current hour. The weather
            sensor must support weather.get_forecasts which has been introduced with
            HA 2023.9. <br /><br /> You also have the option of <ins>not using</ins>
            the weather <ins>forecast</ins> service here. The current attributes of
            the weather sensor are then used. <br /> This is the successor to the
            old option: <em>Prevent the use of the ''get_forecasts'' service</em>'
          default: daily
          selector:
            select:
              options:
              - label: Use the daily weather forecast service
                value: daily
              - label: Use the hourly weather forecast service
                value: hourly
              - label: Do not use a weather forecast, but the current weather attributes
                value: weather_attributes
              multiple: false
              sort: false
              custom_value: false
        shading_forecast_temp:
          name: "\U0001F975 Sun Shading Forecast Temperature Value"
          description: 'This is the minimum temperature at which shading should be
            activated. When the forecasted temperature rises above this threshold,
            the shading mechanism will engage. There is a special feature when comparing
            the shading forecast temperature. Please continue reading! <br /><br />
            <details> <summary><code><strong>CLICK HERE:</strong> Special Feature</code></summary>

            To enhance the reliability of the shading response, the system includes
            a comparison mechanism. The forecasted shading temperature is evaluated
            against two temperature sensors to ensure optimal performance. <br /><br
            /> <strong>Comparison Mechanism:</strong> The forecast value is evaluated
            in relation to: <br />- <ins>Shading Forecast Temperature Value (this
            input field)</ins> <br />- <ins>Shading Temperature Sensor 2 (e.g. outdoor)</ins>
            <br /><br /> For shading to be triggered, it suffices for either of the
            two sensor values to exceed the configured shading forecast temperature
            value. There is no default temperature value here since February 2025.
            To <ins>not</ins> compare the forecast temperature, leave this field empty.
            <br /><br /> <strong>Important Notes:</strong> Weather forecasts are not
            always accurate. Therefore, incorporating multiple temperature sensors
            allows for a more dependable reading before activating the shading system.

            </details>'
          default: []
          selector:
            number:
              min: 0.0
              max: 50.0
              step: 0.1
              mode: slider
              unit_of_measurement: °C
        shading_weather_conditions:
          name: "\U0001F975 Sun Shading Weather Conditions"
          description: 'Check the following weather conditions when activating the
            shading. **NOTE**: Forecast sensor needs to be defined'
          default:
          - sunny
          - partlycloudy
          - cloudy
          - clear
          selector:
            select:
              multiple: true
              options:
              - clear-night
              - clear
              - cloudy
              - fog
              - hail
              - lightning
              - lightning-rainy
              - partlycloudy
              - pouring
              - rainy
              - snowy
              - snowy-rainy
              - sunny
              - windy
              - windy-variant
              - exceptional
              sort: false
              custom_value: false
        shading_waitingtime_start:
          name: "\U0001F975 Waiting Time For Sun Shading Start"
          description: To avoid overloading the motor, a waiting time can be defined
            here for the start of shading. The shade will then only start if <ins>all</ins>
            mandatory conditions are fulfilled for the entire waiting time.
          default: 300
          selector:
            number:
              min: 0.0
              max: 3600.0
              unit_of_measurement: seconds
              mode: slider
              step: 1.0
        shading_start_behavior:
          name: "\U0001F975 Sun Shading Start Behavior"
          description: Behavior if the shading conditions were not permanently met
            over the period. <p> Reset the detected shading start and wait for another
            trigger The system discards the current shading start detection and waits
            for a new valid trigger condition. </p><p> Checks every few seconds, only
            during the day, as defined in 'Waiting Time for Sun Shading Start' The
            system continues to check periodically—every few seconds during daytime—based
            on the interval specified in the 'Waiting Time for Sun Shading Start'
            setting. However, this only applies if the shading conditions have changed
            negatively between the initial trigger (pending) and the next check (execution).
            </p>
          default: trigger_periodic
          selector:
            select:
              options:
              - label: Reset the detected shading start and wait for another trigger
                value: trigger_reset
              - label: Checks every few seconds, only during the day, as defined in
                  'Waiting Time for Sun Shading Start'
                value: trigger_periodic
              multiple: false
              sort: false
              custom_value: false
              mode: list
        shading_waitingtime_end:
          name: "\U0001F975 Waiting Time For Sun Shading End"
          description: To avoid excessive load on the motor, a waiting time can be
            defined here before the shading is ended. Shading ends if <ins>one</ins>
            of the conditions is <ins>not</ins> fulfilled for the entire waiting time.
          default: 300
          selector:
            number:
              min: 0.0
              max: 3600.0
              unit_of_measurement: seconds
              mode: slider
              step: 1.0
        is_shading_end_immediate_by_sun_position:
          name: "\U0001F975 End Sun Shading Immediately When Out Of Range"
          description: If enabled, shading will end immediately when sun position
            moves outside the defined azimuth or elevation range. If disabled, the
            configured waiting time will be used before ending the shading.
          default: false
          selector:
            boolean: {}
        shading_end_behavior:
          name: "\U0001F975 Sun Shading End Behavior"
          description: Configure how the cover should behave when sun shading ends.
            Choose "Move to close position" for awnings to retract when shading ends.
          default: open_position
          selector:
            select:
              options:
              - label: "\U0001F53C Move to open position (default for blinds / roller
                  shutters)"
                value: open_position
              - label: "\U0001F53B Move to close position (for awnings)"
                value: close_position
              multiple: false
              sort: false
              custom_value: false
              mode: list
    resident_section:
      name: Resident Settings
      description: <br /> <center><code> (1) The purpose of resident mode is to the
        close the cover (without checking the defined times) when the resident sensor
        switches to ‘on/true’. For example, when a resident goes to sleep. <br />
        (2) The cover will stay closed as long as the sensor remains in this state.
        <br /> (3) When the resident sensor switches to ‘off/false’, the cover is
        automatically opened in the morning. <br /> (4) In addition, the usual automatic
        opening of the cover is prevented as long as the sensor is set to ‘on/true’
        or the resident. <br /><br /> All these settings are optional. </code></center><br
        />
      icon: mdi:human-male-female
      collapsed: true
      input:
        resident_sensor:
          name: "\U0001F6CC Resident Sensor"
          description: You can use this to define a resident (input_boolean or binary_sensor)
            for the room
          default: []
          selector:
            entity:
              domain:
              - input_boolean
              - binary_sensor
              - switch
              multiple: false
        resident_config:
          name: "\U0001F6CC Resident Configuration"
          description: Additional configuration options
          default: []
          selector:
            select:
              options:
              - label: "\U0001F53C Open the cover immediately when the sensor goes
                  to 'off/false'?"
                value: resident_opening_enabled
              - label: "\U0001F53B Close the cover immediately when the sensor goes
                  to 'on/true'?"
                value: resident_closing_enabled
              - label: "\U0001F975 Allow sun protection when resident is still present"
                value: resident_allow_shading
              - label: "\U0001F53C Allow opening the cover when resident is still
                  present"
                value: resident_allow_opening
              - label: "\U0001F4A8 Allow ventilation when resident is still present"
                value: resident_allow_ventilation
              multiple: true
              sort: false
              custom_value: false
              mode: list
    override_section:
      name: Manual Override
      description: <br /> <center><code>A Cover Status Helper is required!</code></center><br
        />
      icon: mdi:debug-step-over
      collapsed: true
      input:
        ignore_after_manual_config:
          name: "\U0001F590️ Ignoring/override after manual position changes"
          description: "Ignore or override the following actions after manual position
            changes.\n<details> <summary><code><strong>CLICK HERE:</strong> Further
            description</code></summary>\n\nUltimately, this means that the cover
            will not be opened, closed, etc. if a manual interaction has previously
            been made, e.g. using a wall switch.\n\nThe reason behind this is that
            the human being wins with his decision and his conscious decision is weighted
            higher than the upcoming action of the automation.\n\nAs soon as a cover
            has been moved manually, the status is recorded in the Cover Status Helper.
            This usually means that a person has deliberately decided against a status.\n\n
            \ - If option is not activated: The covers are moved even if a manual
            correction has been made.\n  - If option is activated: The action to open,
            close, etc. is not performed because a conscious decision was made to
            do otherwise due to a manual intervention.\n\n\nA Cover Status Helper
            is required!\n</details>"
          default: []
          selector:
            select:
              options:
              - label: "\U0001F53C Ignore/override next automatic opening after manual
                  position changes"
                value: ignore_opening_after_manual
              - label: "\U0001F53B Ignore/override next automatic closing after manual
                  position changes"
                value: ignore_closing_after_manual
              - label: "\U0001F4A8 Ignore/override next automatic ventilation after
                  manual position changes"
                value: ignore_ventilation_after_manual
              - label: "\U0001F975 Ignore/override next automatic sun shading after
                  manual position changes"
                value: ignore_shading_after_manual
              multiple: true
              sort: false
              custom_value: false
              mode: list
        reset_override_config:
          name: "\U0001F5D1️ Reset manual override"
          description: If the detection of the manual position change was activated
            above, you may need a way to reset this status. Otherwise, the next cover
            movements will be permanently ignored or overridden. Or you have not activated
            an individual action, e.g. when closing the covers, which resets the status.
          default: reset_disabled
          selector:
            select:
              options:
              - label: No timed reset for manual override
                value: reset_disabled
              - label: Reset at a specified time (see below)
                value: reset_fixed_time
              - label: Reset after a timeout in minutes (see below)
                value: reset_timeout
              multiple: false
              sort: false
              custom_value: false
              mode: list
        reset_override_time:
          name: "\U0001F5D1️ Time to reset manual override"
          description: At what time do you want the manual detection to be reset?
          default: 00:01:00
          selector:
            time: {}
        reset_override_timeout:
          name: "\U0001F5D1️ Number of minutes until reset manual override"
          description: After how many minutes should it be reset?
          default: 5
          selector:
            number:
              min: 0.0
              max: 1440.0
              unit_of_measurement: minutes
              mode: slider
              step: 1.0
    delay_section:
      description: <br /> <center><code>Take into account that, for example, waiting
        times are added when brightness changes or shading is started. It is therefore
        better to use smaller values here. It is only a matter of separating the different
        covers in terms of time.</code></center><br />
      name: Delay Settings
      icon: mdi:timer-outline
      collapsed: true
      input:
        drive_delay_fix:
          name: "\U0001F55B Fixed Drive Delay"
          description: Fixed drive delay to avoid radio interferences. <br /><br />`Optional`
          default: 0
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider
        drive_delay_random:
          name: "\U0001F55B Random Drive Delay"
          description: Additional random delay. <br /><br />`Optional`
          default: 5
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider
        tilt_delay:
          name: "\U0001F55B Tilt Delay"
          description: Delay between <em>set_cover_position</em> and <em>set_cover_tilt_position</em>.
            Only necessary when using the tilt functions. This separates the two commands
            in terms of time. <br /><br />`Optional`
          default: 0
          selector:
            number:
              min: 0.0
              max: 600.0
              unit_of_measurement: seconds
              step: 1.0
              mode: slider
    condition_section:
      name: Additional Conditions
      description: <br /> <center><code>All these settings are optional</code></center><br
        />
      icon: mdi:help-rhombus-outline
      collapsed: true
      input:
        auto_global_condition:
          name: ❓ Additional Condition for the entire automation
          description: This condition allows you to control the execution of the <ins>entire</ins>
            automation dynamically and outside of the blueprint configuration. With
            this option you could enable a party mode. <br /><br /> If the result
            of this condition is <ins>true</ins>, the automation will continue.<br
            /> The result of the conditions must be <ins>false</ins>, for the automation
            to stop in this sequence. <br /><br /> Forcing Open/Close/Shading/Ventilation
            is therefore only possible if this condition remains empty or becomes
            valid.
          default: []
          selector:
            condition: {}
        auto_up_condition:
          name: "\U0001F53C Additional Condition For Opening The Cover"
          description: This condition can be used to dynamically control the <ins>opening</ins>
            of the cover. You can use this, for example, if the covers normally don't
            open, but you really want to do it on vacation. <br /><br /> If the result
            of this condition is <ins>true</ins>, the automation will continue.<br
            /> The result of the conditions must be <ins>false</ins>, for the automation
            to stop in this sequence.
          default: []
          selector:
            condition: {}
        auto_down_condition:
          name: "\U0001F53B Additional Condition For Closing The Cover"
          description: This condition can be used to dynamically control the <ins>closing</ins>
            of the cover. You can use this, for example, at Christmas time or if you
            want the covers to behave differently while on vacation. <br /><br />
            If the result of this condition is <ins>true</ins>, the automation will
            continue.<br /> The result of the conditions must be <ins>false</ins>,
            for the automation to stop in this sequence.
          default: []
          selector:
            condition: {}
        auto_ventilate_condition:
          name: "\U0001F4A8 Additional Condition For Activating Ventilation"
          description: This condition can be used to dynamically control the <ins>start
            of the ventilation</ins> of the cover. <br /><br /> If the result of this
            condition is <ins>true</ins>, the automation will continue.<br /> The
            result of the conditions must be <ins>false</ins>, for the automation
            to stop in this sequence.
          default: []
          selector:
            condition: {}
        auto_ventilate_end_condition:
          name: "\U0001F4A8 Additional Condition For Disabling Ventilation"
          description: This condition can be used to dynamically control the <ins>end
            of the ventilation</ins> of the cover. <br /><br /> If the result of this
            condition is <ins>true</ins>, the automation will continue.<br /> The
            result of the conditions must be <ins>false</ins>, for the automation
            to stop in this sequence.
          default: []
          selector:
            condition: {}
        auto_shading_start_condition:
          name: "\U0001F975 Additional Condition When Activating Sun Shading"
          description: 'This condition can be used to dynamically control the <ins>shading-IN-automation</ins>
            of the cover. This can be useful if you want to temporarily disable automation
            (e.g. because of control by other automations). <br /><br /> If the result
            of this condition is <ins>true</ins>, the automation will continue.<br
            /> The result of the conditions must be <ins>false</ins>, for the automation
            to stop in this sequence. <br /> Another example: Here you could also
            set that the shading is only triggered in the summer season.'
          default: []
          selector:
            condition: {}
        auto_shading_tilt_condition:
          name: "\U0001F975 Additional Condition For Sun Shading Tilt"
          description: 'This condition can be used to dynamically control the <ins>shading_tilt-IN-automation</ins>
            of the cover. This can be useful if you want to temporarily disable automation
            (e.g. because of control by other automations). <br /> Another example:
            Here you could also set that the tilting is only triggered in the summer
            season. <br /><br /> If the result of this condition is <ins>true</ins>,
            the automation will continue.<br /> The result of the conditions must
            be <ins>false</ins>, for the automation to stop in this sequence.'
          default: []
          selector:
            condition: {}
        auto_shading_end_condition:
          name: "\U0001F975 Additional Condition When Deactivating  Sun Shading"
          description: This condition can be used to dynamically control the <ins>shading-OUT-automation</ins>
            of the cover. This can be useful if you want to temporarily disable automation
            (e.g. because of control by other automations). <br /> If the result of
            this condition is <ins>true</ins>, the automation will continue.<br />
            The result of the conditions must be <ins>false</ins>, for the automation
            to stop in this sequence.
          default: []
          selector:
            condition: {}
    force_section:
      name: Force Features
      description: "<br /> This can be used for the following purposes under certain
        circumstances: Antifreeze, RainProtection or WindProtection. <br /><br />
        Note:\n  - However, after forcing a state, you must ensure that you move to
        the correct target position yourself. You are responsible for getting CCA
        back on track.\n  - This cannot be performed in CCA and must therefore be
        done via a separate automation. Presumably in the same automation that sets
        the \"Force\"-boolean. It is sufficient, by the way, if a configured position
        is targeted. CCA then recognises the status.\n  - Force is a final state that
        cannot be cancelled or resetted by CCA.\n  - The default automations (open,
        close, and further) will never be able to override a force. The force feature
        must therefore be cancelled manually beforehand.\n<br /><br />\n<center><code>All
        these settings are optional</code></center><br />"
      icon: mdi:arm-flex
      collapsed: true
      input:
        auto_up_force:
          name: "\U0001F53C Force Immediate Opening via Entity"
          description: If the status of this entity changes to on or true, the cover
            is opened immediately and without further checking.
          default: []
          selector:
            entity:
              domain:
              - input_boolean
              - binary_sensor
              - switch
              multiple: false
        auto_down_force:
          name: "\U0001F53B Force Immediate Closing via Entity"
          description: If the status of this entity changes to on or true, the cover
            is closed immediately and without further checking.
          default: []
          selector:
            entity:
              domain:
              - input_boolean
              - binary_sensor
              - switch
              multiple: false
        auto_ventilate_force:
          name: "\U0001F4A8 Force Immediate Ventilation via Entity"
          description: If the status of this entity changes to on or true, the cover
            is immediately set to ventilation mode and without further checking.
          default: []
          selector:
            entity:
              domain:
              - input_boolean
              - binary_sensor
              - switch
              multiple: false
        auto_shading_start_force:
          name: "\U0001F975 Force Activation Sun Shading via Entity"
          description: If the status of this entity changes to on or true, the shading
            is immediately activated and without further checking.
          default: []
          selector:
            entity:
              domain:
              - input_boolean
              - binary_sensor
              - switch
              multiple: false
    actions_section:
      name: Additional Actions
      description: <br /> <center><code>All these settings are optional</code></center><br
        />
      icon: mdi:run
      collapsed: true
      input:
        auto_up_action_before:
          name: "\U0001F53C Additional Actions Before Opening The Cover"
          description: Additional actions to run <ins>before</ins> opening the cover
          default: []
          selector:
            action: {}
        auto_up_action:
          name: "\U0001F53C Additional Actions After Opening The Cover"
          description: Additional actions to run <ins>after</ins> opening the cover
          default: []
          selector:
            action: {}
        auto_down_action_before:
          name: "\U0001F53B Additional Actions Before Closing The Cover"
          description: Additional actions to run <ins>before</ins> closing the cover
          default: []
          selector:
            action: {}
        auto_down_action:
          name: "\U0001F53B Additional Actions After Closing The Cover"
          description: Additional actions to run <ins>after</ins> closing the cover
          default: []
          selector:
            action: {}
        auto_ventilate_action_before:
          name: "\U0001F4A8 Additional Actions Before Ventilating The Cover"
          description: Additional actions to run <ins>before</ins> ventilating the
            cover
          default: []
          selector:
            action: {}
        auto_ventilate_action:
          name: "\U0001F4A8 Additional Actions After Ventilating The Cover"
          description: Additional actions to run <ins>after</ins> ventilating the
            cover
          default: []
          selector:
            action: {}
        auto_shading_start_action_before:
          name: "\U0001F975 Additional Actions Before Activating Sun Shading"
          description: Additional actions to run <ins>before</ins> activating sun
            shading
          default: []
          selector:
            action: {}
        auto_shading_start_action:
          name: "\U0001F975 Additional Actions After Activating Sun Shading"
          description: Additional actions to run <ins>after</ins> activating sun shading
          default: []
          selector:
            action: {}
        auto_shading_end_action_before:
          name: "\U0001F975 Additional Actions Before Disabling Sun Shading"
          description: Additional actions to run <ins>before</ins> disabling sun shading
          default: []
          selector:
            action: {}
        auto_shading_end_action:
          name: "\U0001F975 Additional Actions After Disabling Sun Shading"
          description: Additional actions to run <ins>after</ins> disabling sun shading
          default: []
          selector:
            action: {}
        auto_manual_action:
          name: "\U0001F590️ Additional Actions After Manual Change"
          description: Additional actions after a manual change to the covers
          default: []
          selector:
            action: {}
        auto_override_reset_action:
          name: "\U0001F5D1️ Additional Actions After Override Reset"
          description: Additional actions to be taken after resetting the manual override
          default: []
          selector:
            action: {}
    configcheck_section:
      name: Configuration Check
      icon: mdi:invoice-text-check-outline
      collapsed: true
      input:
        check_config:
          name: ✔️ Check Configuration
          description: With this boolean, you can enable or disable the basic plausibility
            check for the configuration. The check only takes place if the automation
            is executed manually.
          default: false
          selector:
            boolean: {}
        check_config_debuglevel:
          name: ✔️ Check Configuration - Debug level
          description: Choose the debug level for Syslog messages in case of configuration
            issues <br /> Please make sure that it suits your Home Assistant logger
            default level.
          default: info
          selector:
            select:
              multiple: false
              mode: dropdown
              options:
              - critical
              - debug
              - error
              - info
              - warning
              sort: false
              custom_value: false
trigger_variables:
  blind: !input blind
  open_position: !input open_position
  close_position: !input close_position
  ventilate_position: !input ventilate_position
  shading_position: !input shading_position
  position_tolerance: !input position_tolerance
  open_tilt_position: !input open_tilt_position
  close_tilt_position: !input close_tilt_position
  ventilate_tilt_position: !input ventilate_tilt_position
  shading_tilt_elevation_1: !input shading_tilt_elevation_1
  shading_tilt_elevation_2: !input shading_tilt_elevation_2
  shading_tilt_elevation_3: !input shading_tilt_elevation_3
  shading_tilt_position_1: !input shading_tilt_position_1
  shading_tilt_position_2: !input shading_tilt_position_2
  shading_tilt_position_3: !input shading_tilt_position_3
  auto_options: !input auto_options
  time_up_early: !input time_up_early
  time_up_early_non_workday: !input time_up_early_non_workday
  time_up_late: !input time_up_late
  time_up_late_non_workday: !input time_up_late_non_workday
  time_down_early: !input time_down_early
  time_down_early_non_workday: !input time_down_early_non_workday
  time_down_late: !input time_down_late
  time_down_late_non_workday: !input time_down_late_non_workday
  workday_sensor_today: !input workday_sensor
  workday_sensor_tomorrow: !input workday_sensor_tomorrow
  default_brightness_sensor: !input default_brightness_sensor
  brightness_up: !input brightness_up
  brightness_down: !input brightness_down
  default_sun_sensor: !input default_sun_sensor
  sun_elevation_up: !input sun_elevation_up
  sun_elevation_down: !input sun_elevation_down
  resident_sensor: !input resident_sensor
  contact_window_tilted: !input contact_window_tilted
  contact_window_opened: !input contact_window_opened
  lockout_tilted_options: !input lockout_tilted_options
  lockout_tilted_when_closing: '{{ ''lockout_tilted_closing'' in lockout_tilted_options
    }}'
  lockout_tilted_when_shading_starts: '{{ ''lockout_tilted_shading_start'' in lockout_tilted_options
    }}'
  lockout_tilted_when_shading_ends: '{{ ''lockout_tilted_shading_end'' in lockout_tilted_options
    }}'
  time_control: !input time_control
  time_schedule_helper: !input time_schedule_helper
  shading_brightness_sensor: !input shading_brightness_sensor
  shading_temperatur_sensor1: !input shading_temperatur_sensor1
  shading_temperatur_sensor2: !input shading_temperatur_sensor2
  shading_min_temperatur1: !input shading_min_temperatur1
  shading_min_temperatur2: !input shading_min_temperatur2
  shading_temperature_hysteresis1: !input shading_temperature_hysteresis1
  shading_temperature_hysteresis2: !input shading_temperature_hysteresis2
  shading_azimuth_start: !input shading_azimuth_start
  shading_azimuth_end: !input shading_azimuth_end
  shading_elevation_min: !input shading_elevation_min
  shading_elevation_max: !input shading_elevation_max
  shading_sun_brightness_start: !input shading_sun_brightness_start
  shading_sun_brightness_end: !input shading_sun_brightness_end
  shading_forecast_sensor: !input shading_forecast_sensor
  shading_forecast_type: !input shading_forecast_type
  shading_forecast_temp: !input shading_forecast_temp
  shading_weather_conditions: !input shading_weather_conditions
  is_shading_enabled: '{{ ''auto_shading_enabled'' in auto_options }}'
  cover_tilt_config: !input cover_tilt_config
  is_cover_tilt_enabled: '{{ ''cover_tilt_enabled'' in cover_tilt_config }}'
  is_up_enabled: '{{ ''auto_up_enabled'' in auto_options }}'
  is_down_enabled: '{{ ''auto_down_enabled'' in auto_options }}'
  is_brightness_enabled: '{{ ''auto_brightness_enabled'' in auto_options }}'
  is_sun_elevation_enabled: '{{ ''auto_sun_enabled'' in auto_options }}'
  is_ventilation_enabled: '{{ ''auto_ventilate_enabled'' in auto_options }}'
  is_time_field_enabled: '{{ ''time_control_input'' in time_control }}'
  is_schedule_helper_enabled: '{{ ''time_control_schedule'' in time_control and time_schedule_helper
    != [] }}'
  is_time_control_disabled: '{{ ''time_control_disabled'' in time_control }}'
  reset_override_config: !input reset_override_config
  reset_override_time: !input reset_override_time
  reset_override_timeout: !input reset_override_timeout
  is_reset_disabled: '{{ ''reset_disabled'' in reset_override_config }}'
  is_reset_fixed_time: '{{ ''reset_fixed_time'' in reset_override_config }}'
  is_reset_timeout: '{{ ''reset_timeout'' in reset_override_config }}'
  cover_status_options: !input cover_status_options
  cover_status_helper: !input cover_status_helper
variables:
  version: 2025.06.07
  blind_entities: '{{ expand(blind) | map(attribute=''entity_id'') | list }}'
  current_position: '{{ state_attr(blind, ''current_position'') | int(default=101)
    }}'
  current_tilt_position: '{{ state_attr(blind,''current_tilt_position'') | int(default=101)
    }}'
  current_sun_azimuth: '{{ state_attr(default_sun_sensor, ''azimuth'') }}'
  current_sun_elevation: '{{ state_attr(default_sun_sensor, ''elevation'') }}'
  drive_delay_fix: !input drive_delay_fix
  drive_delay_random: !input drive_delay_random
  drive_time: !input drive_time
  time_up_early_today: "{% if workday_sensor_today != [] and is_state(workday_sensor_today,
    'off') %}\n  {{ time_up_early_non_workday }}\n{% else %}\n  {{ time_up_early }}\n{%
    endif %}"
  time_up_late_today: "{% if workday_sensor_today != [] and is_state(workday_sensor_today,
    'off') %}\n  {{ time_up_late_non_workday }}\n{% else %}\n  {{ time_up_late }}\n{%
    endif %}"
  time_down_early_today: "{% if workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow,
    'off') %}\n  {{ time_down_early_non_workday }}\n{% elif workday_sensor_tomorrow
    != [] and is_state(workday_sensor_tomorrow, 'on') %}\n  {{ time_down_early }}\n{%
    elif workday_sensor_today != [] and is_state(workday_sensor_today, 'off') %}\n
    \ {{ time_down_early_non_workday }}\n{% else %}\n  {{ time_down_early }}\n{% endif
    %}"
  time_down_late_today: "{% if workday_sensor_tomorrow != [] and is_state(workday_sensor_tomorrow,
    'off') %}\n  {{ time_down_late_non_workday }}\n{% elif workday_sensor_tomorrow
    != [] and is_state(workday_sensor_tomorrow, 'on') %}\n  {{ time_down_late }}\n{%
    elif workday_sensor_today != [] and is_state(workday_sensor_today, 'off') %}\n
    \ {{ time_down_late_non_workday }}\n{% else %}\n  {{ time_down_late }}\n{% endif
    %}"
  auto_up_force: !input auto_up_force
  auto_down_force: !input auto_down_force
  auto_ventilate_force: !input auto_ventilate_force
  auto_shading_start_force: !input auto_shading_start_force
  auto_up_force_disabled: '{{ auto_up_force == [] or (auto_up_force != [] and is_state(auto_up_force,
    [''false'', ''off''])) }}'
  auto_down_force_disabled: '{{ auto_down_force == [] or (auto_down_force != [] and
    is_state(auto_down_force, [''false'', ''off''])) }}'
  auto_ventilate_force_disabled: '{{ auto_ventilate_force == [] or (auto_ventilate_force
    != [] and is_state(auto_ventilate_force, [''false'', ''off''])) }}'
  auto_shading_start_force_disabled: '{{ auto_shading_start_force == [] or (auto_shading_start_force
    != [] and is_state(auto_shading_start_force, [''false'', ''off''])) }}'
  is_cover_tilt_enabled_and_possible: '{{ is_cover_tilt_enabled and state_attr(blind,
    ''current_tilt_position'') != none }}'
  cover_tilt_reposition_config: !input cover_tilt_reposition_config
  is_cover_tilt_reposition_enabled: '{{ ''cover_tilt_reposition_enabled'' in cover_tilt_reposition_config
    }}'
  shading_tilt_position: "{% set elevation = current_sun_elevation | int(default=0)
    %} {% if elevation >= shading_tilt_elevation_3 | int %}\n  {{ shading_tilt_position_3
    | int }}\n{% elif elevation >= shading_tilt_elevation_2 | int %}\n  {{ shading_tilt_position_2
    | int }}\n{% elif elevation >= shading_tilt_elevation_1 | int %}\n  {{ shading_tilt_position_1
    | int }}\n{% else %}\n  {{ 0 | int }}\n{% endif %}"
  shading_waitingtime_start: !input shading_waitingtime_start
  shading_waitingtime_end: !input shading_waitingtime_end
  is_shading_end_immediate_by_sun_position: !input is_shading_end_immediate_by_sun_position
  shading_start_behavior: !input shading_start_behavior
  shading_end_behavior: !input shading_end_behavior
  start_shading_trigger_reset: '{{ ''trigger_reset'' in shading_start_behavior }}'
  start_shading_trigger_periodic: '{{ ''trigger_periodic'' in shading_start_behavior
    }}'
  is_status_helper_enabled: "{{\n  'cover_helper_enabled' in cover_status_options
    and\n  cover_status_helper != [] and\n  states(cover_status_helper) != [] and\n
    \ states(cover_status_helper) | regex_match(\"((\\[[^\\}]+)?\\{s*[^\\}\\{]{3,}?:.*\\}([^\\{]+\\])?)\")
    and\n  states(cover_status_helper) not in ['unavailable', 'none', 'unknown']\n}}"
  helper_state_json: '{{ states(cover_status_helper) | from_json if is_status_helper_enabled
    else {} }}'
  is_helper_open: '{{ is_status_helper_enabled and (helper_state_json | regex_search(''open''))
    and (helper_state_json.open.a | default(false) | bool) }}'
  is_helper_closed: '{{ is_status_helper_enabled and (helper_state_json | regex_search(''close''))
    and (helper_state_json.close.a | default(false) | bool) }}'
  is_helper_shaded: "{{\n  'shading' in helper_state_json and\n  helper_state_json.shading.a
    | default(false) | bool and\n  not (helper_state_json.shading.p | default(false)
    | bool and\n      helper_state_json.shading.q | default(false) | bool)\n}}"
  is_helper_shading_start: '{{ is_status_helper_enabled and (helper_state_json | regex_search(''shading''))
    and (helper_state_json.shading.p | default(false) | bool) }}'
  is_helper_shading_end: '{{ is_status_helper_enabled and (helper_state_json | regex_search(''shading''))
    and (helper_state_json.shading.q | default(false) | bool) }}'
  is_helper_vent_partial: '{{ is_status_helper_enabled and (helper_state_json | regex_search(''vpart''))
    and (helper_state_json.vpart.a | default(false) | bool) }}'
  is_helper_vent_full: '{{ is_status_helper_enabled and (helper_state_json | regex_search(''vfull''))
    and (helper_state_json.vfull.a | default(false) | bool) }}'
  is_helper_manual: '{{ is_status_helper_enabled and (helper_state_json | regex_search(''manual''))
    and (helper_state_json.manual.a | default(false) | bool) }}'
  ts_helper_open: '{{ helper_state_json.open.t | default(0) if (is_status_helper_enabled
    and (helper_state_json | regex_search(''open''))) else 0 }}'
  ts_helper_closed: '{{ helper_state_json.close.t | default(0) if (is_status_helper_enabled
    and (helper_state_json | regex_search(''close''))) else 0 }}'
  ts_helper_shaded: '{{ helper_state_json.shading.t | default(0) if (is_status_helper_enabled
    and (helper_state_json | regex_search(''shading''))) else 0 }}'
  ts_helper_vent_partial: '{{ helper_state_json.vpart.t | default(0) if (is_status_helper_enabled
    and (helper_state_json | regex_search(''vpart''))) else 0 }}'
  ts_helper_vent_full: '{{ helper_state_json.vfull.t | default(0) if (is_status_helper_enabled
    and (helper_state_json | regex_search(''vfull''))) else 0 }}'
  ts_helper_manual: '{{ helper_state_json.manual.t | default(0) if (is_status_helper_enabled
    and (helper_state_json | regex_search(''manual''))) else 0 }}'
  in_open_position: "{% set pos = current_position %} {% set tilt = current_tilt_position
    %} {% set min = open_position - position_tolerance %} {% set max = open_position
    + position_tolerance %} {{\n  (pos >= min and pos <= max)\n  and (\n    (not is_cover_tilt_enabled_and_possible)\n
    \   or (is_cover_tilt_enabled_and_possible and tilt == open_tilt_position)\n  )\n}}"
  in_close_position: "{% set pos = current_position %} {% set tilt = current_tilt_position
    %} {% set min = close_position - position_tolerance %} {% set max = close_position
    + position_tolerance %} {{\n  (pos >= min and pos <= max)\n  and (\n    (not is_cover_tilt_enabled_and_possible)\n
    \   or (is_cover_tilt_enabled_and_possible and tilt == close_tilt_position)\n
    \ )\n}}"
  in_shading_position: "{% set pos = current_position %} {% set tilt = current_tilt_position
    %} {% set min = shading_position - position_tolerance %} {% set max = shading_position
    + position_tolerance %} {{\n  is_shading_enabled\n  and (pos >= min and pos <=
    max)\n  and (\n    (not is_cover_tilt_enabled_and_possible)\n    or (tilt == shading_tilt_position)\n
    \ )\n}}"
  in_ventilate_position: "{% set pos = current_position %} {% set tilt = current_tilt_position
    %} {% set min = ventilate_position - position_tolerance %} {% set max = ventilate_position
    + position_tolerance %} {{\n  is_ventilation_enabled\n  and (pos >= min and pos
    <= max)\n  and (\n    (not is_cover_tilt_enabled_and_possible)\n    or (tilt ==
    \ ventilate_tilt_position)\n  )\n}}"
  individual_config: !input individual_config
  prevent_higher_position_closing: '{{ ''prevent_higher_position_closing'' in individual_config
    }}'
  prevent_lowering_when_closing_if_shaded: '{{ ''prevent_lowering_when_closing_if_shaded''
    in individual_config }}'
  prevent_forecast_service: '{{ ''weather_attributes'' in shading_forecast_type }}'
  prevent_shading_end_if_closed: '{{ ''prevent_shading_end_if_closed'' in individual_config
    }}'
  prevent_opening_after_shading_end: '{{ ''prevent_opening_after_shading_end'' in
    individual_config }}'
  prevent_opening_after_ventilation_end: '{{ ''prevent_opening_after_ventilation_end''
    in individual_config }}'
  prevent_default_cover_actions: '{{ ''prevent_default_cover_actions'' in individual_config
    }}'
  prevent_shading_multiple_times: '{{ ''prevent_shading_multiple_times'' in individual_config
    }}'
  prevent_opening_multiple_times: '{{ ''prevent_opening_multiple_times'' in individual_config
    }}'
  prevent_closing_multiple_times: '{{ ''prevent_closing_multiple_times'' in individual_config
    }}'
  resident_config: !input resident_config
  resident_opening_enabled: '{{ ''resident_opening_enabled'' in resident_config }}'
  resident_closing_enabled: '{{ ''resident_closing_enabled'' in resident_config }}'
  resident_allow_shading: '{{ ''resident_allow_shading'' in resident_config }}'
  resident_allow_opening: '{{ ''resident_allow_opening'' in resident_config }}'
  resident_allow_ventilation: '{{ ''resident_allow_ventilation'' in resident_config
    }}'
  ignore_after_manual_config: !input ignore_after_manual_config
  override_opening_after_manual: '{{ ''ignore_opening_after_manual'' in ignore_after_manual_config
    }}'
  override_closing_after_manual: '{{ ''ignore_closing_after_manual'' in ignore_after_manual_config
    }}'
  override_ventilation_after_manual: '{{ ''ignore_ventilation_after_manual'' in ignore_after_manual_config
    }}'
  override_shading_after_manual: '{{ ''ignore_shading_after_manual'' in ignore_after_manual_config
    }}'
  auto_ventilate_options: !input auto_ventilate_options
  ventilation_delay_enabled: '{{ ''ventilation_delay_enabled'' in auto_ventilate_options
    }}'
  ventilation_if_lower_enabled: '{{ ''ventilation_if_lower_enabled'' in auto_ventilate_options
    }}'
  ventilation_after_shading_end: '{{ ''ventilation_after_shading_end'' in auto_ventilate_options
    }}'
  check_config: !input check_config
  check_config_debuglevel: !input check_config_debuglevel
  check_status_helper_length: '{{ state_attr(cover_status_helper, ''max'') if is_status_helper_enabled
    else None }}'
mode: single
max_exceeded: silent
triggers:
- platform: template
  value_template: '{% set is_non_workday = (workday_sensor_today != [] and is_state(workday_sensor_today,
    ''off'')) %} {% set early = time_up_early_non_workday if is_non_workday else time_up_early
    %} {{ now() >= today_at(early) }}'
  enabled: '{{ is_time_field_enabled }}'
  id: t_open_1
- platform: template
  value_template: '{% set is_non_workday = (workday_sensor_today != [] and is_state(workday_sensor_today,
    ''off'')) %} {% set early = time_up_early_non_workday if is_non_workday else time_up_early
    %} {% set late = time_up_late_non_workday if is_non_workday else time_up_late
    %} {{ early != late and now() >= today_at(late) }}'
  enabled: '{{ is_time_field_enabled }}'
  id: t_open_2
- platform: template
  value_template: '{{ is_state(time_schedule_helper, [''true'', ''on'']) }}'
  enabled: '{{ is_schedule_helper_enabled and time_schedule_helper != [] }}'
  id: t_open_3
- platform: template
  value_template: '{{ states(default_brightness_sensor) | float(default=brightness_up)
    > brightness_up }}'
  for:
    seconds: !input brightness_time_duration
  enabled: '{{ is_brightness_enabled and default_brightness_sensor != [] }}'
  id: t_open_4
- platform: template
  value_template: '{{ state_attr(default_sun_sensor, ''elevation'') | float(default=sun_elevation_up)
    > sun_elevation_up }}'
  for:
    seconds: !input sun_time_duration
  enabled: '{{ is_sun_elevation_enabled and default_sun_sensor != [] }}'
  id: t_open_5
- platform: state
  entity_id: !input resident_sensor
  from: 'on'
  to: 'off'
  id: t_open_6
- platform: state
  entity_id: !input auto_up_force
  from: 'off'
  to: 'on'
  id: t_force_open
- platform: template
  value_template: '{% set is_tomorrow = workday_sensor_tomorrow != [] %} {% set is_today
    = workday_sensor_today != [] %} {% set tomorrow_off = is_tomorrow and is_state(workday_sensor_tomorrow,
    ''off'') %} {% set today_off = is_today and is_state(workday_sensor_today, ''off'')
    %} {% set early = time_down_early_non_workday if tomorrow_off or today_off else
    time_down_early %} {{ now() >= today_at(early) }}'
  enabled: '{{ is_time_field_enabled }}'
  id: t_close_1
- platform: template
  value_template: '{% set is_tomorrow = workday_sensor_tomorrow != [] %} {% set is_today
    = workday_sensor_today != [] %} {% set tomorrow_off = is_tomorrow and is_state(workday_sensor_tomorrow,
    ''off'') %} {% set today_off = is_today and is_state(workday_sensor_today, ''off'')
    %} {% set is_non_workday = today_off or tomorrow_off %} {% set early = time_down_early_non_workday
    if is_non_workday else time_down_early %} {% set late = time_down_late_non_workday
    if is_non_workday else time_down_late %} {{ early != late and now() >= today_at(late)
    }}'
  enabled: '{{ is_time_field_enabled }}'
  id: t_close_2
- platform: template
  value_template: '{{ is_state(time_schedule_helper, [''false'', ''off'']) }}'
  enabled: '{{ is_schedule_helper_enabled and time_schedule_helper != [] }}'
  id: t_close_3
- platform: template
  value_template: '{{ states(default_brightness_sensor) | float(default=brightness_down)
    < brightness_down }}'
  for:
    seconds: !input brightness_time_duration
  enabled: '{{ is_brightness_enabled and default_brightness_sensor != [] }}'
  id: t_close_4
- platform: template
  value_template: '{{ state_attr(default_sun_sensor, ''elevation'') | float(default=sun_elevation_down)
    < sun_elevation_down }}'
  for:
    seconds: !input sun_time_duration
  enabled: '{{ is_sun_elevation_enabled and default_sun_sensor != [] }}'
  id: t_close_5
- platform: state
  entity_id: !input resident_sensor
  from: 'off'
  to: 'on'
  id: t_close_6
- platform: state
  entity_id: !input auto_down_force
  from: 'off'
  to: 'on'
  id: t_force_close
- platform: template
  value_template: '{{ is_state(contact_window_tilted, [''true'', ''on'']) }}'
  enabled: '{{ is_ventilation_enabled and contact_window_tilted != [] }}'
  id: t_contact_tilted_on
  for:
    seconds: !input contact_delay_trigger
- platform: template
  value_template: '{{ is_state(contact_window_tilted, [''false'', ''off'']) }}'
  enabled: '{{ is_ventilation_enabled and contact_window_tilted != [] }}'
  id: t_contact_tilted_off
  for:
    seconds: !input contact_delay_trigger
- platform: template
  value_template: '{{ is_state(contact_window_opened, [''true'', ''on'']) }}'
  enabled: '{{ is_ventilation_enabled and contact_window_opened != [] }}'
  id: t_contact_opened_on
  for:
    seconds: !input contact_delay_trigger
- platform: template
  value_template: '{{ is_state(contact_window_opened, [''false'', ''off'']) }}'
  enabled: '{{ is_ventilation_enabled and contact_window_opened != [] }}'
  id: t_contact_opened_off
  for:
    seconds: !input contact_delay_trigger
- platform: state
  entity_id: !input auto_ventilate_force
  from: 'off'
  to: 'on'
  id: t_force_vent
- platform: template
  value_template: "{{\n  state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_start)
    > shading_azimuth_start and\n  state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end)
    < shading_azimuth_end and\n  state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_min)
    > shading_elevation_min and\n  state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_max)
    < shading_elevation_max\n}}"
  enabled: '{{ is_shading_enabled and default_sun_sensor != [] }}'
  id: t_shading_start_pending_1
- platform: template
  value_template: '{{ states(shading_brightness_sensor) | float(default=shading_sun_brightness_start)
    > shading_sun_brightness_start }}'
  enabled: '{{ is_shading_enabled and shading_brightness_sensor != [] }}'
  id: t_shading_start_pending_2
- platform: template
  value_template: '{{ states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1)
    > shading_min_temperatur1 }}'
  enabled: '{{ is_shading_enabled and shading_temperatur_sensor1 != [] }}'
  id: t_shading_start_pending_3
- platform: template
  value_template: '{{ states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2)
    > shading_min_temperatur2 }}'
  enabled: '{{ is_shading_enabled and shading_temperatur_sensor2 != [] }}'
  id: t_shading_start_pending_4
- platform: template
  value_template: '{{ states(shading_forecast_sensor) in shading_weather_conditions
    }}'
  enabled: '{{ is_shading_enabled and shading_forecast_sensor != [] }}'
  id: t_shading_start_pending_5
- platform: template
  value_template: "{% if\n  states(cover_status_helper) != [] and\n  states(cover_status_helper)
    | regex_match(\"((\\[[^\\}]+)?\\{s*[^\\}\\{]{3,}?:.*\\}([^\\{]+\\])?)\") and\n
    \ states(cover_status_helper) not in [\"unavailable\", \"none\", \"unknown\"]
    and\n  states(cover_status_helper)|from_json|regex_search('shading') and\n  (states(cover_status_helper)|from_json).shading.p
    is defined and\n  (states(cover_status_helper)|from_json).shading.p > 0\n%}\n
    \ {{ now() >= ( (states(cover_status_helper)|from_json).shading.p) | as_datetime
    | as_local }}\n{% endif %}"
  enabled: '{{ is_shading_enabled and cover_status_helper != [] }}'
  id: t_shading_start_execution
- platform: state
  entity_id: !input auto_shading_start_force
  from: 'off'
  to: 'on'
  id: t_force_shading_start
- platform: template
  value_template: "{{\n  state_attr(default_sun_sensor, 'elevation') < shading_tilt_elevation_1
    and\n  (states(cover_status_helper)|from_json).shading.a == 1\n}}"
  enabled: '{{ is_shading_enabled and is_cover_tilt_enabled and default_sun_sensor
    != [] }}'
  id: t_shading_tilt_1
- platform: template
  value_template: "{{\n  state_attr(default_sun_sensor, 'elevation') < shading_tilt_elevation_2
    and\n  state_attr(default_sun_sensor, 'elevation') >= shading_tilt_elevation_1
    and\n  (states(cover_status_helper)|from_json).shading.a == 1\n}}"
  enabled: '{{ is_shading_enabled and is_cover_tilt_enabled and default_sun_sensor
    != [] }}'
  id: t_shading_tilt_2
- platform: template
  value_template: "{{\n  state_attr(default_sun_sensor, 'elevation') < shading_tilt_elevation_3
    and\n  state_attr(default_sun_sensor, 'elevation') >= shading_tilt_elevation_2
    and\n  (states(cover_status_helper)|from_json).shading.a == 1\n}}"
  enabled: '{{ is_shading_enabled and is_cover_tilt_enabled and default_sun_sensor
    != [] }}'
  id: t_shading_tilt_3
- platform: template
  value_template: "{{\n  state_attr(default_sun_sensor, 'elevation') >= shading_tilt_elevation_3
    and\n  (states(cover_status_helper)|from_json).shading.a == 1\n}}"
  enabled: '{{ is_shading_enabled and is_cover_tilt_enabled and default_sun_sensor
    != [] }}'
  id: t_shading_tilt_4
- platform: template
  value_template: '{{ states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1)
    < (shading_min_temperatur1 - shading_temperature_hysteresis1) }}'
  enabled: '{{ is_shading_enabled and shading_temperatur_sensor1 != [] }}'
  id: t_shading_end_pending_1
- platform: template
  value_template: '{{ states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2)
    < (shading_min_temperatur2 - shading_temperature_hysteresis2) }}'
  enabled: '{{ is_shading_enabled and shading_temperatur_sensor2 != [] }}'
  id: t_shading_end_pending_2
- platform: template
  value_template: '{{ states(shading_brightness_sensor) | float(default=shading_sun_brightness_end)
    < shading_sun_brightness_end }}'
  enabled: '{{ is_shading_enabled and shading_brightness_sensor != [] }}'
  id: t_shading_end_pending_3
- platform: template
  value_template: '{{ states(shading_forecast_sensor) not in shading_weather_conditions
    }}'
  enabled: '{{ is_shading_enabled and shading_weather_conditions != [] and shading_forecast_sensor
    != [] }}'
  id: t_shading_end_pending_4
- platform: template
  value_template: "{{\n    (state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end)
    > shading_azimuth_end) or\n    (state_attr(default_sun_sensor, 'elevation') |
    float(default=shading_elevation_max) > shading_elevation_max) or\n    (state_attr(default_sun_sensor,
    'elevation') | float(default=shading_elevation_min) < shading_elevation_min)\n}}"
  enabled: '{{ is_shading_enabled and default_sun_sensor != [] }}'
  id: t_shading_end_pending_5
- platform: template
  value_template: "{% if\n  states(cover_status_helper) != [] and\n  states(cover_status_helper)
    | regex_match(\"((\\[[^\\}]+)?\\{s*[^\\}\\{]{3,}?:.*\\}([^\\{]+\\])?)\") and\n
    \ states(cover_status_helper) not in [\"unavailable\", \"none\", \"unknown\"]
    and\n  states(cover_status_helper)|from_json|regex_search('shading') and\n  (states(cover_status_helper)|from_json).shading.q
    is defined and\n  (states(cover_status_helper)|from_json).shading.q > 0\n%}\n
    \ {{ now() >= ( (states(cover_status_helper)|from_json).shading.q) | as_datetime
    | as_local }}\n{% endif %}"
  enabled: '{{ is_shading_enabled and cover_status_helper != [] }}'
  id: t_shading_end_execution
- platform: template
  value_template: '{{ now() >= today_at(''23:55:00'') }}'
  id: t_shading_reset
  enabled: '{{ is_shading_enabled }}'
- platform: state
  entity_id: !input blind
  attribute: current_position
  id: t_manual_1
  for: 00:01:00
- platform: template
  value_template: '{{ now() >= today_at(reset_override_time) }}'
  enabled: '{{ is_reset_fixed_time }}'
  id: t_manual_2
  for: 00:00:02
- platform: template
  value_template: "{% if\n  states(cover_status_helper) != [] and\n  states(cover_status_helper)
    | regex_match(\"((\\[[^\\}]+)?\\{s*[^\\}\\{]{3,}?:.*\\}([^\\{]+\\])?)\") and\n
    \ states(cover_status_helper) not in [\"unavailable\", \"none\", \"unknown\"]
    and\n  states(cover_status_helper)|from_json|regex_search('manual') and\n  (states(cover_status_helper)|from_json).manual.t
    is defined and\n  (states(cover_status_helper)|from_json).manual.a is defined
    and\n  (states(cover_status_helper)|from_json).manual.a | bool is true\n%}\n  {{
    now() >= ( (states(cover_status_helper)|from_json).manual.t + 60 * reset_override_timeout)
    | as_datetime | as_local }}\n{% endif %}"
  enabled: '{{ is_reset_timeout and cover_status_helper != [] }}'
  id: t_manual_3
  for: 00:00:02
- platform: state
  entity_id: !input blind
  attribute: current_tilt_position
  id: t_manual_4
  for: 00:01:00
conditions:
- condition: !input auto_global_condition
- or:
  - '{{ trigger.to_state is not defined }}'
  - '{{ trigger.to_state is defined and trigger.to_state.state not in [''unavailable'',
    ''unknown'',''none'', ''query failed''] }}'
actions:
- if:
  - '{{ is_shading_enabled }}'
  - '{{ not prevent_forecast_service }}'
  - '{{ (shading_forecast_sensor != [] ) }}'
  - '{{ states(shading_forecast_sensor) not in [''unavailable'', ''unknown'', ''query
    failed'']  }}'
  - '{{ trigger.id is defined }}'
  - '{{ trigger.id | regex_match(''^(t_shading_start|t_open_1|t_open_3)'') }}'
  - '{{ shading_forecast_sensor.startswith(''weather.'') }}'
  then:
  - action: weather.get_forecasts
    target:
      entity_id: !input shading_forecast_sensor
    data:
      type: !input shading_forecast_type
    response_variable: weather_forecast
- if:
  - '{{ ''cover_helper_enabled'' in cover_status_options }}'
  - '{{ cover_status_helper != [] }}'
  - or:
    - '{{ not states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)")
      }}'
    - '{{ states(cover_status_helper) in ["unavailable", "none", "unknown"] }}'
  then:
  - action: input_text.set_value
    data:
      entity_id: !input cover_status_helper
      value: "{% set dict_var = {\n  'open':{'a':0,'t':0},\n  'close':{'a':0,'t':0},\n
        \ 'shading':{'a':0,'t':0,'p':0,'q':0},\n  'vpart':{'a':0,'t':0},\n  'vfull':{'a':0,'t':0},\n
        \ 'manual':{'a':0,'t':0},\n  'v':5,\n  't':as_timestamp(now()) | round(0)\n
        \ }\n%}\n{{ dict_var | to_json }}\n"
- if:
  - '{{ is_status_helper_enabled }}'
  - '{{ (states(cover_status_helper)|from_json).v != 5 }}'
  then:
  - action: input_text.set_value
    data:
      entity_id: !input cover_status_helper
      value: "{% set dict_var = {\n  'open':{'a':is_helper_open|int,'t':ts_helper_open},\n
        \ 'close':{'a':is_helper_closed|int,'t':ts_helper_closed},\n  'shading':{'a':is_helper_shaded|int,'t':ts_helper_shaded,'p':0,'q':0},\n
        \ 'vpart':{'a':is_helper_vent_partial|int,'t':ts_helper_vent_partial},\n  'vfull':{'a':is_helper_vent_full|int,'t':ts_helper_vent_full},\n
        \ 'manual':{'a':is_helper_manual|int,'t':ts_helper_manual},\n  'v':5,\n  't':helper_state_json.t
        | round(0)\n  }\n%}\n{{ dict_var | to_json }}\n"
- choose:
  - alias: Check for opening
    conditions:
    - '{{ is_up_enabled }}'
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id | regex_match(''^(t_open)'') }}'
    - condition: !input auto_up_condition
    - and:
      - '{{ auto_down_force_disabled }}'
      - '{{ auto_ventilate_force_disabled }}'
      - '{{ auto_shading_start_force_disabled }}'
    - '{{ not (is_status_helper_enabled and is_helper_manual and override_opening_after_manual)
      }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ not prevent_opening_multiple_times }}'
      - '{{ is_status_helper_enabled and prevent_opening_multiple_times and (now().day
        != ts_helper_open|timestamp_custom(''%-d'')|int) }}'
    - or:
      - '{{ trigger.id != ''t_open_6'' }}'
      - '{{ trigger.id == ''t_open_6'' and resident_opening_enabled }}'
    - or:
      - '{{ resident_sensor == [] }}'
      - '{{ is_state(resident_sensor, [''false'', ''off'']) }}'
      - and:
        - '{{ resident_allow_opening }}'
        - '{{ is_state(resident_sensor, [''true'', ''on'']) }}'
    - or:
      - and:
        - '{{ is_time_control_disabled }}'
      - and:
        - '{{ is_time_field_enabled }}'
        - '{{ now() >= today_at(time_up_late_today) }}'
        - '{{ now() <= today_at(time_down_late_today) - timedelta(seconds = 5) }}'
      - and:
        - '{{ is_schedule_helper_enabled }}'
        - '{{ time_schedule_helper != [] }}'
        - '{{ not is_brightness_enabled }}'
        - '{{ not is_sun_elevation_enabled }}'
        - '{{ is_state(time_schedule_helper, ''on'') }}'
        - '{{ trigger.id in [''t_open_3'', ''t_open_6''] }}'
      - and:
        - or:
          - and:
            - '{{ is_time_control_disabled }}'
          - and:
            - '{{ is_time_field_enabled }}'
            - '{{ now() >= today_at(time_up_early_today) }}'
            - '{{ now() <= today_at(time_up_late_today) + timedelta(seconds = 5) }}'
          - and:
            - '{{ is_schedule_helper_enabled }}'
            - '{{ time_schedule_helper != [] }}'
            - '{{ is_state(time_schedule_helper, ''on'') }}'
            - '{{ now() >= today_at([time_up_early, time_up_early_non_workday] | min)
              - timedelta(seconds = 5) }}'
            - '{{ now() <= today_at([time_up_late, time_up_late_non_workday] | max)
              + timedelta(seconds = 5) }}'
        - or:
          - or:
            - '{{ is_brightness_enabled and default_brightness_sensor == [] }}'
            - '{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor)
              | float(default=brightness_up) > brightness_up) }}'
          - or:
            - '{{ is_sun_elevation_enabled and default_sun_sensor == [] }}'
            - '{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation
              | float(default=sun_elevation_up) > sun_elevation_up) }}'
    sequence:
    - delay:
        seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
          +1) | random }}'
    - choose:
      - alias: Shading detected. Move to shading position
        conditions:
        - '{{ is_status_helper_enabled }}'
        - '{{ is_helper_shaded }}'
        - '{{ not in_shading_position }}'
        sequence:
        - choose: []
          default: !input auto_shading_start_action_before
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':1,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - alias: Moving the cover to shading position
                action: cover.set_cover_position
                data:
                  position: !input shading_position
                target:
                  entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: '{{ shading_tilt_position | int }}'
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_shading_start_action
      - alias: Normal opening of the cover
        conditions:
        - '{{ not in_shading_position }}'
        - or:
          - '{{ is_status_helper_enabled and not is_helper_open }}'
          - '{{ not in_open_position }}'
        sequence:
        - choose: []
          default: !input auto_up_action_before
        - if:
          - '{{ is_status_helper_enabled }}'
          then:
          - action: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
                set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
                | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
                \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
                \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
                | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - if:
                - '{{ open_position == 100 }}'
                then:
                - alias: Moving the cover to open position
                  action: cover.open_cover
                  data: {}
                  target:
                    entity_id: '{{ repeat.item }}'
                else:
                - alias: Moving the cover to open position
                  action: cover.set_cover_position
                  data:
                    position: !input open_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: !input open_tilt_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_up_action
    - stop: 'Stop automation: OPEN'
  - alias: Check for closing cover
    conditions:
    - '{{ is_down_enabled }}'
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id | regex_match(''^(t_close)'') }}'
    - condition: !input auto_down_condition
    - and:
      - '{{ auto_up_force_disabled }}'
      - '{{ auto_ventilate_force_disabled }}'
      - '{{ auto_shading_start_force_disabled }}'
    - or:
      - '{{ is_status_helper_enabled and not is_helper_closed }}'
      - '{{ not in_close_position }}'
    - '{{ not (is_status_helper_enabled and is_helper_manual and override_closing_after_manual)
      }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ not prevent_closing_multiple_times }}'
      - '{{ is_status_helper_enabled and prevent_closing_multiple_times and (ts_helper_closed
        < today_at(time_down_early_today) | as_timestamp) }}'
    - or:
      - and:
        - '{{ is_time_control_disabled }}'
      - and:
        - '{{ is_time_field_enabled }}'
        - '{{ now() >= today_at(time_down_late_today) }}'
      - and:
        - '{{ is_schedule_helper_enabled }}'
        - '{{ time_schedule_helper != [] }}'
        - '{{ is_state(time_schedule_helper, ''off'') }}'
        - '{{ trigger.id == ''t_close_3'' }}'
      - and:
        - or:
          - and:
            - '{{ is_time_control_disabled }}'
          - and:
            - '{{ is_time_field_enabled }}'
            - '{{ now() >= today_at(time_down_early_today) }}'
            - '{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5)
              }}'
          - and:
            - '{{ is_schedule_helper_enabled }}'
            - '{{ time_schedule_helper != [] }}'
            - '{{ is_state(time_schedule_helper, ''on'') }}'
            - '{{ now() >= today_at([time_down_early, time_down_early_non_workday]
              | min) - timedelta(seconds = 5) }}'
            - '{{ now() <= today_at([time_down_late, time_down_late_non_workday] |
              max) + timedelta(seconds = 5) }}'
        - or:
          - or:
            - '{{ is_brightness_enabled and default_brightness_sensor == [] }}'
            - '{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor)
              | float(default=brightness_down) < brightness_down) }}'
          - or:
            - '{{ is_sun_elevation_enabled and default_sun_sensor == [] }}'
            - '{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation
              | float(default=sun_elevation_down) < sun_elevation_down) }}'
      - and:
        - '{{ trigger.id == ''t_close_6'' }}'
        - '{{ resident_sensor != [] }}'
        - '{{ is_state(resident_sensor, [''true'', ''on'']) }}'
        - '{{ resident_closing_enabled }}'
    sequence:
    - choose:
      - alias: Lockout protection when closing
        conditions:
        - '{{ is_ventilation_enabled }}'
        - '{{ is_status_helper_enabled }}'
        - or:
          - and:
            - '{{ contact_window_opened != [] }}'
            - '{{ is_state(contact_window_opened, [''true'', ''on'']) }}'
          - and:
            - '{{ lockout_tilted_when_closing }}'
            - '{{ contact_window_tilted != [] }}'
            - '{{ is_state(contact_window_tilted, [''true'', ''on'']) }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
              \ 'close':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
      - alias: Window tilted. No lockout. Move to ventilation position instead of
          closing
        conditions:
        - '{{ is_ventilation_enabled }}'
        - '{{ is_status_helper_enabled }}'
        - '{{ contact_window_tilted != [] }}'
        - '{{ is_state(contact_window_tilted, [''true'', ''on'']) }}'
        - '{{ not lockout_tilted_when_closing }}'
        - or:
          - '{{ contact_window_opened == [] }}'
          - '{{ is_state(contact_window_opened, [''false'', ''off'']) }}'
        sequence:
        - choose: []
          default: !input auto_ventilate_action_before
        - delay:
            seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
              +1) | random }}'
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
              \ 'close':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - alias: Moving the cover to the partial ventilation position
                action: cover.set_cover_position
                data:
                  position: !input ventilate_position
                target:
                  entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: !input ventilate_tilt_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_ventilate_action
      - alias: Only status change if cover is already 'near' the close position
        conditions:
        - or:
          - and:
            - '{{ is_status_helper_enabled }}'
            - '{{ prevent_lowering_when_closing_if_shaded }}'
            - '{{ is_helper_shaded }}'
            - '{{ close_position > shading_position }}'
          - and:
            - '{{ prevent_lowering_when_closing_if_shaded }}'
            - '{{ in_shading_position }}'
            - '{{ close_position > shading_position }}'
          - and:
            - '{{ prevent_higher_position_closing }}'
            - '{{ (current_position <= close_position) }}'
        sequence:
        - if:
          - '{{ is_status_helper_enabled }}'
          then:
          - action: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
                set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
                \ 'close':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
                \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
                \ 't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new | to_json
                }}\n"
      default:
      - choose: []
        default: !input auto_down_action_before
      - alias: Normal closing of the cover
        delay:
          seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
            +1) | random }}'
      - if:
        - '{{ is_status_helper_enabled }}'
        then:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
              \ 'close':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
      - if:
        - '{{ not prevent_default_cover_actions}}'
        then:
        - repeat:
            for_each: '{{ blind_entities|list }}'
            sequence:
            - if:
              - '{{ close_position == 0 }}'
              then:
              - alias: Moving the cover to close position
                action: cover.close_cover
                data: {}
                target:
                  entity_id: '{{ repeat.item }}'
              else:
              - alias: Moving the cover to close position
                action: cover.set_cover_position
                data:
                  position: !input close_position
                target:
                  entity_id: '{{ repeat.item }}'
            - if:
              - '{{ is_cover_tilt_enabled_and_possible }}'
              - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
              then:
              - alias: Tilt Delay
                delay:
                  seconds: !input tilt_delay
              - alias: Moving the cover to tilt position
                action: cover.set_cover_tilt_position
                data:
                  tilt_position: !input close_tilt_position
                target:
                  entity_id: '{{ repeat.item }}'
            - delay:
                seconds: '{{ (range(1, 3) | random | int) }}'
      - choose: []
        default: !input auto_down_action
    - stop: 'Stop automation: CLOSE'
  - alias: Check for shading start
    conditions:
    - '{{ is_shading_enabled }}'
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id | regex_match(''^(t_shading_start|t_open_1|t_open_3)'') }}'
    - '{{ is_status_helper_enabled }}'
    - condition: !input auto_shading_start_condition
    - and:
      - '{{ auto_up_force_disabled }}'
      - '{{ auto_down_force_disabled }}'
      - '{{ auto_ventilate_force_disabled }}'
    - or:
      - '{{ not is_helper_shaded }}'
      - '{{ not (is_helper_vent_partial or is_helper_vent_full) }}'
    - or:
      - and:
        - '{{ not is_cover_tilt_enabled_and_possible }}'
        - '{{ not in_shading_position }}'
      - and:
        - '{{ is_cover_tilt_enabled_and_possible }}'
        - '{{ current_position >= shading_position }}'
    - '{{ not (is_helper_manual and override_shading_after_manual) }}'
    - or:
      - '{{ not prevent_shading_multiple_times }}'
      - '{{ prevent_shading_multiple_times and (now().day != ts_helper_shaded|timestamp_custom(''%-d'')
        | int) }}'
      - '{{ trigger.id | regex_match(''^(t_shading_start_execution)'') }}'
    sequence:
    - if:
      - '{{ current_sun_azimuth > shading_azimuth_start and current_sun_azimuth <
        shading_azimuth_end }}'
      - '{{ current_sun_elevation > shading_elevation_min and current_sun_elevation
        < shading_elevation_max }}'
      - or:
        - '{{ shading_brightness_sensor == [] }}'
        - '{{ states(shading_brightness_sensor) | float(default=shading_sun_brightness_start)
          > shading_sun_brightness_start }}'
      - or:
        - '{{ shading_temperatur_sensor1 == [] }}'
        - '{{ states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1)
          > shading_min_temperatur1 }}'
      - or:
        - '{{ shading_temperatur_sensor2 == [] }}'
        - '{{ states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2)
          > shading_min_temperatur2 }}'
      - or:
        - '{{ shading_forecast_sensor == [] }}'
        - '{{ shading_forecast_temp == [] }}'
        - and:
          - '{{ shading_forecast_sensor.startswith(''sensor.'') }}'
          - '{{ states(shading_forecast_sensor) | float(default=shading_forecast_temp
            - 1) > shading_forecast_temp }}'
        - and:
          - '{{ shading_forecast_sensor.startswith(''weather.'') }}'
          - '{{ prevent_forecast_service }}'
          - '{{ state_attr(shading_forecast_sensor, ''temperature'') | float(default=shading_forecast_temp
            - 1) > shading_forecast_temp }}'
        - and:
          - '{{ shading_forecast_sensor.startswith(''weather.'') }}'
          - '{{ not prevent_forecast_service }}'
          - '{{ weather_forecast is defined }}'
          - '{{ weather_forecast[shading_forecast_sensor].forecast[0].temperature
            | float(default=shading_forecast_temp - 1) > shading_forecast_temp }}'
        - '{{ (shading_temperatur_sensor2 != [] ) and (states(shading_temperatur_sensor2)
          | float(default=shading_forecast_temp) > shading_forecast_temp) }}'
      - or:
        - '{{ shading_forecast_sensor == [] }}'
        - '{{ shading_weather_conditions == [] }}'
        - '{{ shading_forecast_sensor.startswith(''sensor.'') }}'
        - and:
          - '{{ shading_forecast_sensor.startswith(''weather.'') }}'
          - '{{ prevent_forecast_service }}'
          - '{{ states(shading_forecast_sensor) in shading_weather_conditions }}'
        - and:
          - '{{ shading_forecast_sensor.startswith(''weather.'') }}'
          - '{{ not prevent_forecast_service }}'
          - '{{ weather_forecast is defined }}'
          - '{{ weather_forecast[shading_forecast_sensor].forecast[0].condition in
            shading_weather_conditions }}'
      then:
      - choose:
        - alias: Shading detected. Save next execution time and pending status
          conditions:
          - '{{ trigger.id | regex_match(''^(t_shading_start_pending)'') }}'
          - '{{ not is_helper_shading_start }}'
          sequence:
          - action: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
                set dict_new = dict(dict_var, **{\n  'shading':{'a':1,'t':as_timestamp(now())
                | round(0), 'p':(as_timestamp(now()) + shading_waitingtime_start)
                | round(0),'q':0 },\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{
                dict_new | to_json }}\n"
        - alias: Consider lockout protection when shading starts
          conditions:
          - '{{ trigger.id | regex_match(''^(t_shading_start_execution)'') }}'
          - '{{ is_helper_shading_start }}'
          - '{{ is_ventilation_enabled }}'
          - or:
            - and:
              - '{{ contact_window_opened != [] }}'
              - '{{ is_state(contact_window_opened, [''true'', ''on'']) }}'
            - and:
              - '{{ lockout_tilted_when_shading_starts }}'
              - '{{ contact_window_tilted != [] }}'
              - '{{ is_state(contact_window_tilted, [''true'', ''on'']) }}'
          sequence:
          - action: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
                set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
                | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':1,'t':as_timestamp(now())
                | round(0),'p':0,'q':0 },\n  'vpart':{'a':0,'t':dict_var.vpart.t},\n
                \ 'vfull':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'manual':{'a':0,'t':dict_var.manual.t},\n
                \ 't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new | to_json
                }}\n"
        - alias: Start Shading
          conditions:
          - '{{ trigger.id | regex_match(''^(t_shading_start_execution)'') }}'
          - '{{ is_helper_shading_start }}'
          - or:
            - and:
              - '{{ not is_cover_tilt_enabled_and_possible }}'
              - '{{ current_position > shading_position }}'
            - and:
              - '{{ is_cover_tilt_enabled_and_possible }}'
              - '{{ current_position >= shading_position }}'
          - or:
            - and:
              - '{{ is_time_control_disabled }}'
            - and:
              - '{{ is_time_field_enabled }}'
              - '{{ now() >= today_at(time_up_early_today) }}'
              - '{{ now() <= today_at(time_down_late_today) + timedelta(seconds =
                5) }}'
            - and:
              - '{{ is_schedule_helper_enabled }}'
              - '{{ time_schedule_helper != [] }}'
              - '{{ is_state(time_schedule_helper, ''on'') }}'
          - or:
            - '{{ resident_sensor == [] }}'
            - '{{ is_state(resident_sensor, [''false'', ''off'']) }}'
            - and:
              - '{{ resident_allow_shading }}'
              - '{{ is_state(resident_sensor, [''true'', ''on'']) }}'
          sequence:
          - delay:
              seconds: '{{ range(drive_delay_fix | int(0), drive_delay_fix | int(0)
                + drive_delay_random | int(0) +1) | random }}'
          - choose: []
            default: !input auto_shading_start_action_before
          - action: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
                set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
                | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':1,'t':as_timestamp(now())
                | round(0),'p':0,'q':0 },\n  'vpart':{'a':0,'t':dict_var.vpart.t},\n
                \ 'vfull':{'a':0,'t':dict_var.vfull.t},\n  'manual':{'a':0,'t':dict_var.manual.t},\n
                \ 't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new | to_json
                }}\n"
          - if:
            - '{{ not prevent_default_cover_actions}}'
            then:
            - repeat:
                for_each: '{{ blind_entities|list }}'
                sequence:
                - alias: Moving the cover to shading position
                  action: cover.set_cover_position
                  data:
                    position: !input shading_position
                  target:
                    entity_id: '{{ repeat.item }}'
                - if:
                  - '{{ is_cover_tilt_enabled_and_possible }}'
                  - '{{ state_attr(repeat.item, ''current_tilt_position'') != none
                    }}'
                  then:
                  - alias: Tilt Delay
                    delay:
                      seconds: !input tilt_delay
                  - alias: Moving the cover to tilt position
                    action: cover.set_cover_tilt_position
                    data:
                      tilt_position: '{{ shading_tilt_position | int }}'
                    target:
                      entity_id: '{{ repeat.item }}'
                - delay:
                    seconds: '{{ (range(1, 3) | random | int) }}'
          - choose: []
            default: !input auto_shading_start_action
        - alias: Save shading state for the future
          conditions:
          - '{{ trigger.id | regex_match(''^(t_shading_start_execution)'') }}'
          - '{{ is_helper_shading_start }}'
          - '{{ is_helper_closed }}'
          sequence:
          - action: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
                set dict_new = dict(dict_var, **{\n  'shading':{'a':1,'t':as_timestamp(now())
                | round(0),'p':0,'q':0 },\n  't':as_timestamp(now()) | round(0)\n
                \ })\n%}\n{{ dict_new | to_json }}\n"
      - stop: 'Stop automation: SHADING START'
      else:
      - choose:
        - alias: Shading conditions were not met consistently and it should be checked
            again periodically in a few seconds
          conditions:
          - '{{ trigger.id | regex_match(''^(t_shading_start_execution)'') }}'
          - '{{ is_helper_shading_start }}'
          - '{{ start_shading_trigger_periodic }}'
          - or:
            - and:
              - '{{ is_time_control_disabled }}'
              - '{{ is_helper_open }}'
            - and:
              - '{{ is_time_field_enabled }}'
              - '{{ now() >= today_at(time_up_early_today) }}'
              - '{{ now() <= today_at(time_down_late_today) + timedelta(seconds =
                5) }}'
            - and:
              - '{{ is_schedule_helper_enabled }}'
              - '{{ time_schedule_helper != [] }}'
              - '{{ is_state(time_schedule_helper, ''on'') }}'
          sequence:
          - action: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
                set dict_new = dict(dict_var, **{\n  'shading':{'a':1,'t':as_timestamp(now())
                | round(0), 'p':(as_timestamp(now()) + shading_waitingtime_start)
                | round(0),'q':0 },\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{
                dict_new | to_json }}\n"
        - alias: Shading conditions were not consistently met and the next new trigger
            should be waited for
          conditions:
          - '{{ trigger.id | regex_match(''^(t_shading_start_execution)'') }}'
          - '{{ is_helper_shading_start }}'
          - '{{ start_shading_trigger_reset }}'
          sequence:
          - action: input_text.set_value
            data:
              entity_id: !input cover_status_helper
              value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
                set dict_new = dict(dict_var, **{\n  'shading':{'a':0,'t':as_timestamp(now())
                | round(0), 'p':0 ,'q':0 },\n  't':as_timestamp(now()) | round(0)\n
                \ })\n%}\n{{ dict_new | to_json }}\n"
  - alias: Check for shading tilt
    conditions:
    - '{{ is_shading_enabled }}'
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id | regex_match(''^(t_shading_tilt)'') }}'
    - '{{ is_status_helper_enabled }}'
    - and:
      - '{{ is_helper_shaded }}'
      - '{{ not is_helper_shading_start }}'
    - '{{ is_cover_tilt_enabled_and_possible }}'
    - condition: !input auto_shading_tilt_condition
    - and:
      - '{{ auto_up_force_disabled }}'
      - '{{ auto_down_force_disabled }}'
      - '{{ auto_ventilate_force_disabled }}'
    - '{{ not (is_helper_vent_partial or is_helper_vent_full) }}'
    - '{{ not (is_helper_manual and override_shading_after_manual) }}'
    sequence:
    - action: input_text.set_value
      data:
        entity_id: !input cover_status_helper
        value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{% set
          dict_new = dict(dict_var, **{\n  'open':{'a':dict_var.open.a,'t':dict_var.open.t},\n
          \ 'close':{'a':dict_var.close.a,'t':dict_var.close.t},\n  'shading':{'a':dict_var.shading.a,'t':dict_var.shading.t,'p':dict_var.shading.p,'q':dict_var.shading.q},\n
          \ 'vpart':{'a':dict_var.vpart.a,'t':dict_var.vpart.t},\n  'vfull':{'a':dict_var.vfull.a,'t':dict_var.vfull.t},\n
          \ 'manual':{'a':dict_var.manual.a,'t':dict_var.manual.t},\n  't':as_timestamp(now())
          | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - alias: Tilt blind to new shading position
            if:
            - '{{ is_cover_tilt_enabled_and_possible }}'
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - if:
              - '{{ is_cover_tilt_reposition_enabled }}'
              then:
              - alias: tilt the cover to close position
                action: cover.set_cover_tilt_position
                data:
                  tilt_position: '{{ 0 | int }}'
                target:
                  entity_id: '{{ repeat.item }}'
              - alias: Tilt Delay
                delay:
                  seconds: !input tilt_delay
            - alias: Moving the cover to tilt position
              action: cover.set_cover_tilt_position
              data:
                tilt_position: '{{ shading_tilt_position | int }}'
              target:
                entity_id: '{{ repeat.item }}'
          - delay:
              seconds: '{{ (range(1, 3) | random | int) }}'
  - alias: Check for shading end
    conditions:
    - '{{ is_shading_enabled }}'
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id | regex_match(''^(t_shading_end)'') }}'
    - '{{ is_status_helper_enabled }}'
    - '{{ is_helper_shaded }}'
    - condition: !input auto_shading_end_condition
    - and:
      - '{{ auto_up_force_disabled }}'
      - '{{ auto_down_force_disabled }}'
      - '{{ auto_ventilate_force_disabled }}'
      - '{{ auto_shading_start_force_disabled }}'
    - or:
      - and:
        - '{{ is_time_control_disabled }}'
      - and:
        - '{{ is_time_field_enabled }}'
        - '{{ now() >= today_at(time_up_early_today) }}'
        - '{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}'
      - and:
        - '{{ is_schedule_helper_enabled }}'
        - '{{ time_schedule_helper != [] }}'
        - '{{ is_state(time_schedule_helper, ''on'') }}'
    - '{{ not (is_helper_manual and override_shading_after_manual) }}'
    - or:
      - '{{ is_helper_shaded }}'
      - '{{ in_shading_position }}'
    - or:
      - '{{ not prevent_shading_end_if_closed }}'
      - '{{ prevent_shading_end_if_closed and not in_close_position}}'
    - or:
      - '{{ resident_sensor == [] }}'
      - '{{ is_state(resident_sensor, [''false'', ''off'']) }}'
    sequence:
    - choose:
      - alias: Shading end detected. Save next execution time and pending status
        conditions:
        - '{{ trigger.id | regex_match(''^(t_shading_end_pending)'') }}'
        - '{{ not is_helper_shading_end }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set local_waitingtime_end = shading_waitingtime_end %}\n{%
              if (is_shading_end_immediate_by_sun_position | default(false)) | bool
              and trigger.id == 't_shading_end_pending_5' %}\n  {% set local_waitingtime_end
              = 10 %} # Almost immediately end shading when sun position out of range\n{%
              endif %}\n{% set dict_var = states(cover_status_helper) | from_json
              %}\n{% set dict_new = dict(dict_var, **{\n  'shading':{'a':1,'t':as_timestamp(now())
              | round(0), 'p':0, 'q':(as_timestamp(now()) + local_waitingtime_end)
              | round(0) },\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - alias: Only tilt open after shading ends
        conditions:
        - '{{ trigger.id | regex_match(''^(t_shading_end_execution)'') }}'
        - '{{ is_helper_shading_end }}'
        - '{{ is_cover_tilt_enabled_and_possible }}'
        - '{{ prevent_opening_after_shading_end}}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
              \ 'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - alias: Moving the cover to open tilt position
                action: cover.set_cover_tilt_position
                data:
                  tilt_position: 50
                target:
                  entity_id: '{{ repeat.item }}'
      - alias: Lockout protection when shading ends
        conditions:
        - '{{ trigger.id | regex_match(''^(t_shading_end_execution)'') }}'
        - '{{ is_helper_shading_end }}'
        - '{{ is_ventilation_enabled }}'
        - '{{ (current_position < ventilate_position) }}'
        - or:
          - and:
            - '{{ contact_window_opened != [] }}'
            - '{{ is_state(contact_window_opened, [''true'', ''on'']) }}'
          - and:
            - '{{ contact_window_tilted != [] }}'
            - '{{ is_state(contact_window_tilted, [''true'', ''on'']) }}'
            - '{{ lockout_tilted_when_shading_ends }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.shading.t},\n  'vfull':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
      - alias: Ventilation after shading ends
        conditions:
        - '{{ trigger.id | regex_match(''^(t_shading_end_execution)'') }}'
        - '{{ is_helper_shading_end }}'
        - '{{ is_ventilation_enabled }}'
        - '{{ ventilation_after_shading_end }}'
        - '{{ contact_window_tilted != [] }}'
        - '{{ is_state(contact_window_tilted, [''true'', ''on'']) }}'
        - '{{ not lockout_tilted_when_closing }}'
        - or:
          - '{{ contact_window_opened == [] }}'
          - '{{ is_state(contact_window_opened, [''false'', ''off'']) }}'
        - or:
          - '{{ (current_position < ventilate_position) }}'
          - '{{ ventilation_if_lower_enabled and (current_position >= ventilate_position)
            }}'
        sequence:
        - delay:
            seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
              +1) | random }}'
        - choose: []
          default: !input auto_ventilate_action_before
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - alias: Move the cover to the partial ventilation position
                action: cover.set_cover_position
                data:
                  position: !input ventilate_position
                target:
                  entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: !input ventilate_tilt_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_ventilate_action
      - alias: Move cover after shading end
        conditions:
        - '{{ trigger.id | regex_match(''^(t_shading_end_execution)'') }}'
        - '{{ is_helper_shading_end }}'
        sequence:
        - delay:
            seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
              +1) | random }}'
        - choose: []
          default: !input auto_shading_end_action_before
        - variables:
            target_position: '{{ close_position if shading_end_behavior == ''close_position''
              else open_position }}'
            target_status: '{{ ''close'' if shading_end_behavior == ''close_position''
              else ''open'' }}'
            target_tilt_position: '{{ close_tilt_position if shading_end_behavior
              == ''close_position'' else open_tilt_position }}'
        - alias: Move cover to {{ target_status }} position
          action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a': 1 if shading_end_behavior
              == 'open_position' else 0,'t': as_timestamp(now()) | round(0) if shading_end_behavior
              == 'open_position' else dict_var.open.t},\n  'close':{'a': 1 if shading_end_behavior
              == 'close_position' else 0,'t': as_timestamp(now()) | round(0) if shading_end_behavior
              == 'close_position' else dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_opening_after_shading_end}}'
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - if:
                - '{{ target_position == 0 or target_position == 100 }}'
                then:
                - alias: Moving the cover to {{ target_status }} position
                  action: cover.{{ 'close' if target_position == 0 else 'open' }}_cover
                  data: {}
                  target:
                    entity_id: '{{ repeat.item }}'
                else:
                - alias: Moving the cover to {{ target_status }} position
                  action: cover.set_cover_position
                  data:
                    position: '{{ target_position }}'
                  target:
                    entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: '{{ target_tilt_position }}'
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_shading_end_action
    - stop: 'Stop automation: SHADING END'
  - alias: Contact sensor opened
    conditions:
    - '{{ is_ventilation_enabled }}'
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id in [''t_contact_tilted_on'', ''t_contact_opened_on''] }}'
    - '{{ is_status_helper_enabled }}'
    - condition: !input auto_ventilate_condition
    - '{{ trigger.from_state.state not in [''unavailable'', ''unknown'', ''none'',
      ''query failed''] }}'
    - '{{ trigger.to_state.state not in [''unavailable'', ''unknown'',''none'', ''query
      failed''] }}'
    - and:
      - '{{ auto_up_force_disabled }}'
      - '{{ auto_down_force_disabled }}'
      - '{{ auto_shading_start_force_disabled }}'
    - or:
      - '{{ resident_sensor == [] }}'
      - '{{ is_state(resident_sensor, [''false'', ''off'']) }}'
      - and:
        - '{{ resident_allow_ventilation }}'
        - '{{ is_state(resident_sensor, [''true'', ''on'']) }}'
    sequence:
    - delay:
        seconds: !input contact_delay_status
    - choose:
      - alias: Window handle to open. Open cover
        conditions:
        - '{{ contact_window_opened != [] }}'
        - '{{ is_state(contact_window_opened, [''true'', ''on'']) }}'
        - '{{ trigger.id == ''t_contact_opened_on'' }}'
        - '{{ not in_open_position }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'vpart':{'a':0,'t':dict_var.vpart.t},\n
              \ 'vfull':{'a':1,'t':as_timestamp(now()) | round(0)},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - if:
                - '{{ open_position == 100 }}'
                then:
                - alias: Moving the cover to open position
                  action: cover.open_cover
                  data: {}
                  target:
                    entity_id: '{{ repeat.item }}'
                else:
                - alias: Moving the cover to open position
                  action: cover.set_cover_position
                  data:
                    position: !input open_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: !input open_tilt_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
      - alias: Window handle to tilt. Move the cover to the partial ventilation position.
        conditions:
        - '{{ contact_window_tilted != [] }}'
        - '{{ is_state(contact_window_tilted, [''true'', ''on'']) }}'
        - '{{ trigger.id == ''t_contact_tilted_on'' }}'
        - or:
          - '{{ (current_position < ventilate_position) }}'
          - and:
            - '{{ is_cover_tilt_enabled_and_possible }}'
            - '{{ (current_position <= ventilate_position) }}'
            - '{{ (current_tilt_position <= ventilate_tilt_position) }}'
          - '{{ ventilation_if_lower_enabled and (current_position >= ventilate_position)
            }}'
        sequence:
        - choose: []
          default: !input auto_ventilate_action_before
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'vpart':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - alias: Moving the cover to the partial ventilation position
                action: cover.set_cover_position
                data:
                  position: !input ventilate_position
                target:
                  entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: !input ventilate_tilt_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_ventilate_action
    - stop: 'Stop automation: CONTACT OPEN'
  - alias: Contact sensor closed
    conditions:
    - '{{ is_ventilation_enabled }}'
    - '{{ trigger.id is defined }}'
    - '{{ is_status_helper_enabled }}'
    - condition: !input auto_ventilate_end_condition
    - '{{ trigger.from_state.state not in [''unavailable'', ''unknown'', ''none'',
      ''query failed''] }}'
    - '{{ trigger.to_state.state not in [''unavailable'', ''unknown'',''none'', ''query
      failed''] }}'
    - and:
      - '{{ auto_up_force_disabled }}'
      - '{{ auto_down_force_disabled }}'
      - '{{ auto_ventilate_force_disabled }}'
      - '{{ auto_shading_start_force_disabled }}'
    - '{{ not (is_helper_manual and override_ventilation_after_manual) }}'
    - or:
      - and:
        - '{{ trigger.id == ''t_contact_tilted_off'' }}'
        - '{{ contact_window_tilted != [] }}'
        - '{{ is_state(contact_window_tilted, [''false'', ''off'']) }}'
        - or:
          - '{{ is_helper_vent_partial }}'
          - '{{ in_ventilate_position }}'
      - and:
        - '{{ trigger.id == ''t_contact_tilted_off'' }}'
        - '{{ contact_window_tilted != [] }}'
        - '{{ is_state(contact_window_tilted, [''false'', ''off'']) }}'
        - '{{ lockout_tilted_when_closing }}'
        - '{{ is_helper_vent_full }}'
      - and:
        - '{{ trigger.id == ''t_contact_opened_off'' }}'
        - '{{ contact_window_opened != [] }}'
        - '{{ is_state(contact_window_opened, [''false'', ''off'']) }}'
        - '{{ is_helper_vent_full }}'
    sequence:
    - if:
      - '{{ ventilation_delay_enabled }}'
      then:
      - delay:
          seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
            +1) | random }}'
      else:
      - delay:
          seconds: !input contact_delay_status
    - choose:
      - alias: Contact sensor closed. Activate partial ventilation
        conditions:
        - '{{ is_helper_vent_full }}'
        - '{{ contact_window_tilted != [] }}'
        - '{{ is_state(contact_window_tilted, [''true'', ''on'']) }}'
        sequence:
        - choose: []
          default: !input auto_ventilate_action_before
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'vpart':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - alias: Move the cover to the partial ventilation position
                action: cover.set_cover_position
                data:
                  position: !input ventilate_position
                target:
                  entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: !input ventilate_tilt_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_ventilate_action
      - alias: Contact sensor closed. Activate shading
        conditions:
        - '{{ is_helper_shaded }}'
        sequence:
        - choose: []
          default: !input auto_shading_start_action_before
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':1,'t':as_timestamp(now())
              | round(0),'p':0,'q':0},\n  'vpart':{'a':0,'t':dict_var.vpart.t},\n
              \ 'vfull':{'a':0,'t':dict_var.vfull.t},\n  'manual':{'a':0,'t':dict_var.manual.t},\n
              \ 't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new | to_json
              }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - alias: Moving the cover to shading position
                action: cover.set_cover_position
                data:
                  position: !input shading_position
                target:
                  entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: '{{ shading_tilt_position | int }}'
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_shading_start_action
      - alias: Contact sensor closed. Open the cover
        conditions:
        - '{{ is_helper_open }}'
        - '{{ not is_helper_shaded }}'
        sequence:
        - choose: []
          default: !input auto_up_action_before
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_opening_after_ventilation_end }}'
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - if:
                - '{{ open_position == 100 }}'
                then:
                - alias: Moving the cover to open position
                  action: cover.open_cover
                  data: {}
                  target:
                    entity_id: '{{ repeat.item }}'
                else:
                - alias: Moving the cover to open position
                  action: cover.set_cover_position
                  data:
                    position: !input open_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: !input open_tilt_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_up_action
      - alias: Contact sensor closed. Close the cover
        conditions:
        - '{{ is_helper_closed }}'
        sequence:
        - choose: []
          default: !input auto_down_action_before
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
              \ 'close':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - if:
          - '{{ not prevent_default_cover_actions}}'
          then:
          - repeat:
              for_each: '{{ blind_entities|list }}'
              sequence:
              - if:
                - '{{ close_position == 0 }}'
                then:
                - alias: Moving the cover to close position
                  action: cover.close_cover
                  data: {}
                  target:
                    entity_id: '{{ repeat.item }}'
                else:
                - alias: Moving the cover to close position
                  action: cover.set_cover_position
                  data:
                    position: !input close_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - if:
                - '{{ is_cover_tilt_enabled_and_possible }}'
                - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
                then:
                - alias: Tilt Delay
                  delay:
                    seconds: !input tilt_delay
                - alias: Moving the cover to tilt position
                  action: cover.set_cover_tilt_position
                  data:
                    tilt_position: !input close_tilt_position
                  target:
                    entity_id: '{{ repeat.item }}'
              - delay:
                  seconds: '{{ (range(1, 3) | random | int) }}'
        - choose: []
          default: !input auto_down_action
    - stop: 'Stop automation: CONTACT CLOSED'
  - alias: Forced opening of the cover
    conditions:
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id == ''t_force_open'' }}'
    sequence:
    - choose: []
      default: !input auto_up_action_before
    - if:
      - '{{ is_status_helper_enabled }}'
      then:
      - action: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
            | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
            \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
            \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now()) |
            round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - if:
            - '{{ open_position == 100 }}'
            then:
            - alias: Moving the cover to open position
              action: cover.open_cover
              data: {}
              target:
                entity_id: '{{ repeat.item }}'
            else:
            - alias: Moving the cover to open position
              action: cover.set_cover_position
              data:
                position: !input open_position
              target:
                entity_id: '{{ repeat.item }}'
          - if:
            - '{{ is_cover_tilt_enabled_and_possible }}'
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Tilt Delay
              delay:
                seconds: !input tilt_delay
            - alias: Moving the cover to tilt position
              action: cover.set_cover_tilt_position
              data:
                tilt_position: !input open_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - delay:
              seconds: '{{ (range(1, 3) | random | int) }}'
    - choose: []
      default: !input auto_up_action
    - stop: 'Stop automation: FORCE OPEN'
  - alias: Forced closing of the cover
    conditions:
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id == ''t_force_close'' }}'
    sequence:
    - choose: []
      default: !input auto_down_action_before
    - if:
      - '{{ is_status_helper_enabled }}'
      then:
      - action: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
            \ 'close':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
            \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
            \ 'manual':{'a':0,'t':dict_var.manual.t},\n  't':as_timestamp(now()) |
            round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - if:
            - '{{ close_position == 0 }}'
            then:
            - alias: Moving the cover to close position
              action: cover.close_cover
              data: {}
              target:
                entity_id: '{{ repeat.item }}'
            else:
            - alias: Moving the cover to close position
              action: cover.set_cover_position
              data:
                position: !input close_position
              target:
                entity_id: '{{ repeat.item }}'
          - if:
            - '{{ is_cover_tilt_enabled_and_possible }}'
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Tilt Delay
              delay:
                seconds: !input tilt_delay
            - alias: Moving the cover to tilt position
              action: cover.set_cover_tilt_position
              data:
                tilt_position: !input close_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - delay:
              seconds: '{{ (range(1, 3) | random | int) }}'
    - choose: []
      default: !input auto_down_action
    - stop: 'Stop automation: FORCE CLOSE'
  - alias: Forced ventilation of the cover
    conditions:
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id == ''t_force_vent'' }}'
    - '{{ is_status_helper_enabled }}'
    sequence:
    - choose: []
      default: !input auto_ventilate_action_before
    - action: input_text.set_value
      data:
        entity_id: !input cover_status_helper
        value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{% set
          dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n  'close':{'a':0,'t':dict_var.close.t},\n
          \ 'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n  'vpart':{'a':1,'t':as_timestamp(now())
          | round(0)},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n  'manual':{'a':0,'t':dict_var.manual.t},\n
          \ 't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - alias: Moving the cover to the partial ventilation position
            action: cover.set_cover_position
            data:
              position: !input ventilate_position
            target:
              entity_id: '{{ repeat.item }}'
          - if:
            - '{{ is_cover_tilt_enabled_and_possible }}'
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Tilt Delay
              delay:
                seconds: !input tilt_delay
            - alias: Moving the cover to tilt position
              action: cover.set_cover_tilt_position
              data:
                tilt_position: !input ventilate_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - delay:
              seconds: '{{ (range(1, 3) | random | int) }}'
    - choose: []
      default: !input auto_ventilate_action
    - stop: 'Stop automation: FORCE VENTILATION'
  - alias: Forced activating of the sun shading
    conditions:
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id == ''t_force_shading_start'' }}'
    - '{{ is_status_helper_enabled }}'
    sequence:
    - choose: []
      default: !input auto_shading_start_action_before
    - action: input_text.set_value
      data:
        entity_id: !input cover_status_helper
        value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{% set
          dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n  'close':{'a':0,'t':dict_var.close.t},\n
          \ 'shading':{'a':1,'t':as_timestamp(now()) | round(0),'p':0,'q':0},\n  'vpart':{'a':0,'t':dict_var.vpart.t},\n
          \ 'vfull':{'a':0,'t':dict_var.vfull.t},\n  'manual':{'a':0,'t':dict_var.manual.t},\n
          \ 't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - alias: Moving the cover to shading position
            action: cover.set_cover_position
            data:
              position: !input shading_position
            target:
              entity_id: '{{ repeat.item }}'
          - if:
            - '{{ is_cover_tilt_enabled_and_possible }}'
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Tilt Delay
              delay:
                seconds: !input tilt_delay
            - alias: Moving the cover to tilt position
              action: cover.set_cover_tilt_position
              data:
                tilt_position: '{{ shading_tilt_position |int }}'
              target:
                entity_id: '{{ repeat.item }}'
          - delay:
              seconds: '{{ (range(1, 3) | random | int) }}'
    - choose: []
      default: !input auto_shading_start_action
    - stop: 'Stop automation: FORCE SHADING START'
  - alias: Checking for manual position changes
    conditions:
    - '{{ trigger.id is defined }}'
    - '{{ this.attributes.current | int(99) == 0 }}'
    - '{{ ''cover_helper_enabled'' in cover_status_options }}'
    - '{{ cover_status_helper != [] }}'
    - '{{ as_timestamp(now()) > helper_state_json.t + drive_time + 60 }}'
    - '{{ trigger.id in [''t_manual_1'', ''t_manual_4''] }}'
    - or:
      - '{{ is_number(trigger.to_state.attributes.current_position) and is_number(trigger.from_state.attributes.current_position)
        }}'
      - '{{ is_number(trigger.to_state.attributes.current_tilt_position) and is_number(trigger.from_state.attributes.current_tilt_position)
        }}'
    - or:
      - '{{ trigger.to_state.attributes.current_position != trigger.from_state.attributes.current_position
        }}'
      - '{{ trigger.to_state.attributes.current_tilt_position != trigger.from_state.attributes.current_tilt_position
        }}'
    - '{{ trigger.from_state.state not in [''unavailable'', ''unknown'', ''none'',
      ''query failed''] }}'
    - '{{ trigger.to_state.state not in [''unavailable'', ''unknown'',''none'', ''query
      failed''] }}'
    sequence:
    - choose:
      - conditions:
        - '{{ trigger.id == ''t_manual_4'' }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':dict_var.open.a,'t':dict_var.open.t},\n
              \ 'close':{'a':dict_var.close.a,'t':dict_var.close.t},\n  'shading':{'a':dict_var.shading.a,'t':dict_var.shading.t,'p':dict_var.shading.p,'q':dict_var.shading.q},\n
              \ 'vpart':{'a':dict_var.vpart.a,'t':dict_var.vpart.t},\n  'vfull':{'a':dict_var.vfull.a,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':1,'t':as_timestamp(now()) | round(0)},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - choose: []
          default: !input auto_manual_action
      - conditions:
        - '{{ is_up_enabled }}'
        - or:
          - '{{ in_open_position }}'
          - '{{ (current_position >= open_position) }}'
          - '{{ (current_position == 100) }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':1,'t':as_timestamp(now()) | round(0)},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - choose: []
          default: !input auto_manual_action
      - conditions:
        - '{{ is_ventilation_enabled }}'
        - '{{ in_ventilate_position }}'
        - '{{ not in_open_position }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
              \ 'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':1,'t':as_timestamp(now()) | round(0)},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - choose: []
          default: !input auto_manual_action
      - conditions:
        - '{{ is_shading_enabled }}'
        - '{{ in_shading_position }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
              \ 'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':1,'t':as_timestamp(now())
              | round(0),'p':0,'q':0},\n  'vpart':{'a':0,'t':dict_var.vpart.t},\n
              \ 'vfull':{'a':0,'t':dict_var.vfull.t},\n  'manual':{'a':1,'t':as_timestamp(now())
              | round(0)},\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
        - choose: []
          default: !input auto_manual_action
      - conditions:
        - '{{ is_down_enabled }}'
        - '{{ not in_shading_position }}'
        - or:
          - '{{ in_close_position }}'
          - '{{ (current_position <= close_position) }}'
          - '{{ (current_position == 0) }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
              \ 'close':{'a':1,'t':as_timestamp(now()) | round(0)},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':1,'t':as_timestamp(now()) | round(0)},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - choose: []
          default: !input auto_manual_action
      - conditions:
        - not:
          - '{{ is_up_enabled and in_open_position }}'
          - '{{ is_down_enabled and in_close_position }}'
          - '{{ is_ventilation_enabled and in_ventilate_position }}'
          - '{{ is_shading_enabled and in_shading_position }}'
        sequence:
        - action: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':0,'t':dict_var.open.t},\n
              \ 'close':{'a':0,'t':dict_var.close.t},\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
              \ 'vpart':{'a':0,'t':dict_var.vpart.t},\n  'vfull':{'a':0,'t':dict_var.vfull.t},\n
              \ 'manual':{'a':1,'t':as_timestamp(now()) | round(0)},\n  't':as_timestamp(now())
              | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
        - choose: []
          default: !input auto_manual_action
  - alias: Reset manual detection
    conditions:
    - '{{ trigger.id is defined }}'
    - '{{ not is_reset_disabled }}'
    - '{{ trigger.id in [''t_manual_2'', ''t_manual_3''] }}'
    sequence:
    - action: input_text.set_value
      data:
        entity_id: !input cover_status_helper
        value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{% set
          dict_new = dict(dict_var, **{\n  'manual':{'a':0,'t':as_timestamp(now())
          | round(0)},\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
          | to_json }}\n"
    - choose: []
      default: !input auto_override_reset_action
  - alias: Reset shading status that is no longer required - but still saved
    conditions:
    - '{{ trigger.id is defined }}'
    - '{{ trigger.id == ''t_shading_reset'' }}'
    - '{{ is_status_helper_enabled }}'
    - '{{ is_helper_shaded }}'
    sequence:
    - delay:
        seconds: '{{ (range(0, 60) | random | int) }}'
    - action: input_text.set_value
      data:
        entity_id: !input cover_status_helper
        value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{% set
          dict_new = dict(dict_var, **{\n  'shading':{'a':0,'t':dict_var.shading.t,'p':0,'q':0},\n
          \ 't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new | to_json }}\n"
  default:
  - if:
    - '{{ check_config }}'
    then:
    - if:
      - '{{ not is_time_control_disabled and (today_at(time_up_early) >= today_at(time_up_late))
        }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: time_up_early should
            be earlier than time_up_late - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ not is_time_control_disabled and (today_at(time_up_early_non_workday)
        >= today_at(time_up_late_non_workday)) }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: time_up_early_non_workday
            should be earlier than time_up_late_non_workday - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ not is_time_control_disabled and (today_at(time_down_early) >= today_at(time_down_late))
        }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: time_down_early
            should be earlier than time_down_late - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ not is_time_control_disabled and (today_at(time_down_early_non_workday)
        >= today_at(time_down_late_non_workday)) }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: time_down_early_non_workday
            should be earlier than time_down_late_non_workday - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ shading_azimuth_start >= shading_azimuth_end }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: shading_azimuth_start
            should be lower than shading_azimuth_end - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ shading_elevation_min >= shading_elevation_max }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: shading_elevation_min
            should be lower than - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ shading_sun_brightness_start <= shading_sun_brightness_end }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: shading_sun_brightness_start
            should be higher than shading_sun_brightness_end - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ ( (resident_sensor != [] ) and (not is_state(resident_sensor, [''false'',
        ''off'',''true'', ''on''])) ) }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: resident_sensor
            is only allowed to be on/off/true/false - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ state_attr(blind, ''current_position'') is none }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: cover is missing
            attribute current_position - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ state_attr(default_sun_sensor, ''elevation'') is none }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: sun sensor is missing
            attribute elevation - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ state_attr(default_sun_sensor, ''azimuth'') is none }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: sun sensor is missing
            attribute azimuth - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - or:
        - '{{ is_brightness_enabled and default_brightness_sensor == [] }}'
        - '{{ is_brightness_enabled and not is_number(states(default_brightness_sensor))
          }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: brightness sensor
            not defined or state is not numeric - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      - '{{ state_attr(cover_status_helper, ''max'') < 254 }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: Wrong length of
            the cover status helper - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - or:
        - '{{ is_shading_enabled }}'
        - '{{ is_ventilation_enabled }}'
      - '{{ not is_status_helper_enabled }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: Shading, ventilation
            and lockout protection require a cover status helper to be configured
            - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ is_schedule_helper_enabled }}'
      - '{{ time_schedule_helper == [] }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: Schedule mode selected
            but no schedule helper specified - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ [in_open_position, in_close_position, in_shading_position, in_ventilate_position].count(True)
        > 1 }}'
      then:
      - action: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: Please revise the
            position values ​​and take the tolerance values ​​into account. The values
            ​​must not overlap - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
  - stop: Stopping the automation - DEFAULT
